{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/plugins/jsx/xhtml.js"],"sourcesContent":["// Use a Map rather than object to avoid unexpected __proto__ access.\nexport default new Map([\n  [\"quot\", \"\\u0022\"],\n  [\"amp\", \"&\"],\n  [\"apos\", \"\\u0027\"],\n  [\"lt\", \"<\"],\n  [\"gt\", \">\"],\n  [\"nbsp\", \"\\u00A0\"],\n  [\"iexcl\", \"\\u00A1\"],\n  [\"cent\", \"\\u00A2\"],\n  [\"pound\", \"\\u00A3\"],\n  [\"curren\", \"\\u00A4\"],\n  [\"yen\", \"\\u00A5\"],\n  [\"brvbar\", \"\\u00A6\"],\n  [\"sect\", \"\\u00A7\"],\n  [\"uml\", \"\\u00A8\"],\n  [\"copy\", \"\\u00A9\"],\n  [\"ordf\", \"\\u00AA\"],\n  [\"laquo\", \"\\u00AB\"],\n  [\"not\", \"\\u00AC\"],\n  [\"shy\", \"\\u00AD\"],\n  [\"reg\", \"\\u00AE\"],\n  [\"macr\", \"\\u00AF\"],\n  [\"deg\", \"\\u00B0\"],\n  [\"plusmn\", \"\\u00B1\"],\n  [\"sup2\", \"\\u00B2\"],\n  [\"sup3\", \"\\u00B3\"],\n  [\"acute\", \"\\u00B4\"],\n  [\"micro\", \"\\u00B5\"],\n  [\"para\", \"\\u00B6\"],\n  [\"middot\", \"\\u00B7\"],\n  [\"cedil\", \"\\u00B8\"],\n  [\"sup1\", \"\\u00B9\"],\n  [\"ordm\", \"\\u00BA\"],\n  [\"raquo\", \"\\u00BB\"],\n  [\"frac14\", \"\\u00BC\"],\n  [\"frac12\", \"\\u00BD\"],\n  [\"frac34\", \"\\u00BE\"],\n  [\"iquest\", \"\\u00BF\"],\n  [\"Agrave\", \"\\u00C0\"],\n  [\"Aacute\", \"\\u00C1\"],\n  [\"Acirc\", \"\\u00C2\"],\n  [\"Atilde\", \"\\u00C3\"],\n  [\"Auml\", \"\\u00C4\"],\n  [\"Aring\", \"\\u00C5\"],\n  [\"AElig\", \"\\u00C6\"],\n  [\"Ccedil\", \"\\u00C7\"],\n  [\"Egrave\", \"\\u00C8\"],\n  [\"Eacute\", \"\\u00C9\"],\n  [\"Ecirc\", \"\\u00CA\"],\n  [\"Euml\", \"\\u00CB\"],\n  [\"Igrave\", \"\\u00CC\"],\n  [\"Iacute\", \"\\u00CD\"],\n  [\"Icirc\", \"\\u00CE\"],\n  [\"Iuml\", \"\\u00CF\"],\n  [\"ETH\", \"\\u00D0\"],\n  [\"Ntilde\", \"\\u00D1\"],\n  [\"Ograve\", \"\\u00D2\"],\n  [\"Oacute\", \"\\u00D3\"],\n  [\"Ocirc\", \"\\u00D4\"],\n  [\"Otilde\", \"\\u00D5\"],\n  [\"Ouml\", \"\\u00D6\"],\n  [\"times\", \"\\u00D7\"],\n  [\"Oslash\", \"\\u00D8\"],\n  [\"Ugrave\", \"\\u00D9\"],\n  [\"Uacute\", \"\\u00DA\"],\n  [\"Ucirc\", \"\\u00DB\"],\n  [\"Uuml\", \"\\u00DC\"],\n  [\"Yacute\", \"\\u00DD\"],\n  [\"THORN\", \"\\u00DE\"],\n  [\"szlig\", \"\\u00DF\"],\n  [\"agrave\", \"\\u00E0\"],\n  [\"aacute\", \"\\u00E1\"],\n  [\"acirc\", \"\\u00E2\"],\n  [\"atilde\", \"\\u00E3\"],\n  [\"auml\", \"\\u00E4\"],\n  [\"aring\", \"\\u00E5\"],\n  [\"aelig\", \"\\u00E6\"],\n  [\"ccedil\", \"\\u00E7\"],\n  [\"egrave\", \"\\u00E8\"],\n  [\"eacute\", \"\\u00E9\"],\n  [\"ecirc\", \"\\u00EA\"],\n  [\"euml\", \"\\u00EB\"],\n  [\"igrave\", \"\\u00EC\"],\n  [\"iacute\", \"\\u00ED\"],\n  [\"icirc\", \"\\u00EE\"],\n  [\"iuml\", \"\\u00EF\"],\n  [\"eth\", \"\\u00F0\"],\n  [\"ntilde\", \"\\u00F1\"],\n  [\"ograve\", \"\\u00F2\"],\n  [\"oacute\", \"\\u00F3\"],\n  [\"ocirc\", \"\\u00F4\"],\n  [\"otilde\", \"\\u00F5\"],\n  [\"ouml\", \"\\u00F6\"],\n  [\"divide\", \"\\u00F7\"],\n  [\"oslash\", \"\\u00F8\"],\n  [\"ugrave\", \"\\u00F9\"],\n  [\"uacute\", \"\\u00FA\"],\n  [\"ucirc\", \"\\u00FB\"],\n  [\"uuml\", \"\\u00FC\"],\n  [\"yacute\", \"\\u00FD\"],\n  [\"thorn\", \"\\u00FE\"],\n  [\"yuml\", \"\\u00FF\"],\n  [\"OElig\", \"\\u0152\"],\n  [\"oelig\", \"\\u0153\"],\n  [\"Scaron\", \"\\u0160\"],\n  [\"scaron\", \"\\u0161\"],\n  [\"Yuml\", \"\\u0178\"],\n  [\"fnof\", \"\\u0192\"],\n  [\"circ\", \"\\u02C6\"],\n  [\"tilde\", \"\\u02DC\"],\n  [\"Alpha\", \"\\u0391\"],\n  [\"Beta\", \"\\u0392\"],\n  [\"Gamma\", \"\\u0393\"],\n  [\"Delta\", \"\\u0394\"],\n  [\"Epsilon\", \"\\u0395\"],\n  [\"Zeta\", \"\\u0396\"],\n  [\"Eta\", \"\\u0397\"],\n  [\"Theta\", \"\\u0398\"],\n  [\"Iota\", \"\\u0399\"],\n  [\"Kappa\", \"\\u039A\"],\n  [\"Lambda\", \"\\u039B\"],\n  [\"Mu\", \"\\u039C\"],\n  [\"Nu\", \"\\u039D\"],\n  [\"Xi\", \"\\u039E\"],\n  [\"Omicron\", \"\\u039F\"],\n  [\"Pi\", \"\\u03A0\"],\n  [\"Rho\", \"\\u03A1\"],\n  [\"Sigma\", \"\\u03A3\"],\n  [\"Tau\", \"\\u03A4\"],\n  [\"Upsilon\", \"\\u03A5\"],\n  [\"Phi\", \"\\u03A6\"],\n  [\"Chi\", \"\\u03A7\"],\n  [\"Psi\", \"\\u03A8\"],\n  [\"Omega\", \"\\u03A9\"],\n  [\"alpha\", \"\\u03B1\"],\n  [\"beta\", \"\\u03B2\"],\n  [\"gamma\", \"\\u03B3\"],\n  [\"delta\", \"\\u03B4\"],\n  [\"epsilon\", \"\\u03B5\"],\n  [\"zeta\", \"\\u03B6\"],\n  [\"eta\", \"\\u03B7\"],\n  [\"theta\", \"\\u03B8\"],\n  [\"iota\", \"\\u03B9\"],\n  [\"kappa\", \"\\u03BA\"],\n  [\"lambda\", \"\\u03BB\"],\n  [\"mu\", \"\\u03BC\"],\n  [\"nu\", \"\\u03BD\"],\n  [\"xi\", \"\\u03BE\"],\n  [\"omicron\", \"\\u03BF\"],\n  [\"pi\", \"\\u03C0\"],\n  [\"rho\", \"\\u03C1\"],\n  [\"sigmaf\", \"\\u03C2\"],\n  [\"sigma\", \"\\u03C3\"],\n  [\"tau\", \"\\u03C4\"],\n  [\"upsilon\", \"\\u03C5\"],\n  [\"phi\", \"\\u03C6\"],\n  [\"chi\", \"\\u03C7\"],\n  [\"psi\", \"\\u03C8\"],\n  [\"omega\", \"\\u03C9\"],\n  [\"thetasym\", \"\\u03D1\"],\n  [\"upsih\", \"\\u03D2\"],\n  [\"piv\", \"\\u03D6\"],\n  [\"ensp\", \"\\u2002\"],\n  [\"emsp\", \"\\u2003\"],\n  [\"thinsp\", \"\\u2009\"],\n  [\"zwnj\", \"\\u200C\"],\n  [\"zwj\", \"\\u200D\"],\n  [\"lrm\", \"\\u200E\"],\n  [\"rlm\", \"\\u200F\"],\n  [\"ndash\", \"\\u2013\"],\n  [\"mdash\", \"\\u2014\"],\n  [\"lsquo\", \"\\u2018\"],\n  [\"rsquo\", \"\\u2019\"],\n  [\"sbquo\", \"\\u201A\"],\n  [\"ldquo\", \"\\u201C\"],\n  [\"rdquo\", \"\\u201D\"],\n  [\"bdquo\", \"\\u201E\"],\n  [\"dagger\", \"\\u2020\"],\n  [\"Dagger\", \"\\u2021\"],\n  [\"bull\", \"\\u2022\"],\n  [\"hellip\", \"\\u2026\"],\n  [\"permil\", \"\\u2030\"],\n  [\"prime\", \"\\u2032\"],\n  [\"Prime\", \"\\u2033\"],\n  [\"lsaquo\", \"\\u2039\"],\n  [\"rsaquo\", \"\\u203A\"],\n  [\"oline\", \"\\u203E\"],\n  [\"frasl\", \"\\u2044\"],\n  [\"euro\", \"\\u20AC\"],\n  [\"image\", \"\\u2111\"],\n  [\"weierp\", \"\\u2118\"],\n  [\"real\", \"\\u211C\"],\n  [\"trade\", \"\\u2122\"],\n  [\"alefsym\", \"\\u2135\"],\n  [\"larr\", \"\\u2190\"],\n  [\"uarr\", \"\\u2191\"],\n  [\"rarr\", \"\\u2192\"],\n  [\"darr\", \"\\u2193\"],\n  [\"harr\", \"\\u2194\"],\n  [\"crarr\", \"\\u21B5\"],\n  [\"lArr\", \"\\u21D0\"],\n  [\"uArr\", \"\\u21D1\"],\n  [\"rArr\", \"\\u21D2\"],\n  [\"dArr\", \"\\u21D3\"],\n  [\"hArr\", \"\\u21D4\"],\n  [\"forall\", \"\\u2200\"],\n  [\"part\", \"\\u2202\"],\n  [\"exist\", \"\\u2203\"],\n  [\"empty\", \"\\u2205\"],\n  [\"nabla\", \"\\u2207\"],\n  [\"isin\", \"\\u2208\"],\n  [\"notin\", \"\\u2209\"],\n  [\"ni\", \"\\u220B\"],\n  [\"prod\", \"\\u220F\"],\n  [\"sum\", \"\\u2211\"],\n  [\"minus\", \"\\u2212\"],\n  [\"lowast\", \"\\u2217\"],\n  [\"radic\", \"\\u221A\"],\n  [\"prop\", \"\\u221D\"],\n  [\"infin\", \"\\u221E\"],\n  [\"ang\", \"\\u2220\"],\n  [\"and\", \"\\u2227\"],\n  [\"or\", \"\\u2228\"],\n  [\"cap\", \"\\u2229\"],\n  [\"cup\", \"\\u222A\"],\n  [\"int\", \"\\u222B\"],\n  [\"there4\", \"\\u2234\"],\n  [\"sim\", \"\\u223C\"],\n  [\"cong\", \"\\u2245\"],\n  [\"asymp\", \"\\u2248\"],\n  [\"ne\", \"\\u2260\"],\n  [\"equiv\", \"\\u2261\"],\n  [\"le\", \"\\u2264\"],\n  [\"ge\", \"\\u2265\"],\n  [\"sub\", \"\\u2282\"],\n  [\"sup\", \"\\u2283\"],\n  [\"nsub\", \"\\u2284\"],\n  [\"sube\", \"\\u2286\"],\n  [\"supe\", \"\\u2287\"],\n  [\"oplus\", \"\\u2295\"],\n  [\"otimes\", \"\\u2297\"],\n  [\"perp\", \"\\u22A5\"],\n  [\"sdot\", \"\\u22C5\"],\n  [\"lceil\", \"\\u2308\"],\n  [\"rceil\", \"\\u2309\"],\n  [\"lfloor\", \"\\u230A\"],\n  [\"rfloor\", \"\\u230B\"],\n  [\"lang\", \"\\u2329\"],\n  [\"rang\", \"\\u232A\"],\n  [\"loz\", \"\\u25CA\"],\n  [\"spades\", \"\\u2660\"],\n  [\"clubs\", \"\\u2663\"],\n  [\"hearts\", \"\\u2665\"],\n  [\"diams\", \"\\u2666\"],\n]);\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1027, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/plugins/typescript.js"],"sourcesContent":["import {\n  eat,\n  finishToken,\n  IdentifierRole,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  nextTemplateToken,\n  popTypeContext,\n  pushTypeContext,\n  rescan_gt,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isJSXEnabled, state} from \"../traverser/base\";\nimport {\n  atPossibleAsync,\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n  parseMaybeAssign,\n  parseMaybeUnary,\n  parsePropertyName,\n  parseTemplate,\n\n} from \"../traverser/expression\";\nimport {parseBindingIdentifier, parseBindingList, parseImportedIdentifier} from \"../traverser/lval\";\nimport {\n  baseParseMaybeDecoratorArguments,\n  parseBlockBody,\n  parseClass,\n  parseFunction,\n  parseFunctionParams,\n  parseStatement,\n  parseVarStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasPrecedingLineBreak,\n  isContextual,\n  isLineTerminator,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\nimport {nextJSXTagToken} from \"./jsx\";\n\nfunction tsIsIdentifier() {\n  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n  // See https://github.com/Microsoft/TypeScript/issues/15008\n  return match(tt.name);\n}\n\nfunction isLiteralPropertyName() {\n  return (\n    match(tt.name) ||\n    Boolean(state.type & TokenType.IS_KEYWORD) ||\n    match(tt.string) ||\n    match(tt.num) ||\n    match(tt.bigint) ||\n    match(tt.decimal)\n  );\n}\n\nfunction tsNextTokenCanFollowModifier() {\n  // Note: TypeScript's implementation is much more complicated because\n  // more things are considered modifiers there.\n  // This implementation only handles modifiers not handled by babylon itself. And \"static\".\n  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n  const snapshot = state.snapshot();\n\n  next();\n  const canFollowModifier =\n    (match(tt.bracketL) ||\n      match(tt.braceL) ||\n      match(tt.star) ||\n      match(tt.ellipsis) ||\n      match(tt.hash) ||\n      isLiteralPropertyName()) &&\n    !hasPrecedingLineBreak();\n\n  if (canFollowModifier) {\n    return true;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n}\n\nexport function tsParseModifiers(allowedModifiers) {\n  while (true) {\n    const modifier = tsParseModifier(allowedModifiers);\n    if (modifier === null) {\n      break;\n    }\n  }\n}\n\n/** Parses a modifier matching one the given modifier names. */\nexport function tsParseModifier(\n  allowedModifiers,\n) {\n  if (!match(tt.name)) {\n    return null;\n  }\n\n  const modifier = state.contextualKeyword;\n  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {\n    switch (modifier) {\n      case ContextualKeyword._readonly:\n        state.tokens[state.tokens.length - 1].type = tt._readonly;\n        break;\n      case ContextualKeyword._abstract:\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        break;\n      case ContextualKeyword._static:\n        state.tokens[state.tokens.length - 1].type = tt._static;\n        break;\n      case ContextualKeyword._public:\n        state.tokens[state.tokens.length - 1].type = tt._public;\n        break;\n      case ContextualKeyword._private:\n        state.tokens[state.tokens.length - 1].type = tt._private;\n        break;\n      case ContextualKeyword._protected:\n        state.tokens[state.tokens.length - 1].type = tt._protected;\n        break;\n      case ContextualKeyword._override:\n        state.tokens[state.tokens.length - 1].type = tt._override;\n        break;\n      case ContextualKeyword._declare:\n        state.tokens[state.tokens.length - 1].type = tt._declare;\n        break;\n      default:\n        break;\n    }\n    return modifier;\n  }\n  return null;\n}\n\nfunction tsParseEntityName() {\n  parseIdentifier();\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction tsParseTypeReference() {\n  tsParseEntityName();\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseThisTypePredicate() {\n  next();\n  tsParseTypeAnnotation();\n}\n\nfunction tsParseThisTypeNode() {\n  next();\n}\n\nfunction tsParseTypeQuery() {\n  expect(tt._typeof);\n  if (match(tt._import)) {\n    tsParseImportType();\n  } else {\n    tsParseEntityName();\n  }\n  if (!hasPrecedingLineBreak() && match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseImportType() {\n  expect(tt._import);\n  expect(tt.parenL);\n  expect(tt.string);\n  expect(tt.parenR);\n  if (eat(tt.dot)) {\n    tsParseEntityName();\n  }\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseTypeParameter() {\n  eat(tt._const);\n  const hadIn = eat(tt._in);\n  const hadOut = eatContextual(ContextualKeyword._out);\n  eat(tt._const);\n  if ((hadIn || hadOut) && !match(tt.name)) {\n    // The \"in\" or \"out\" keyword must have actually been the type parameter\n    // name, so set it as the name.\n    state.tokens[state.tokens.length - 1].type = tt.name;\n  } else {\n    parseIdentifier();\n  }\n\n  if (eat(tt._extends)) {\n    tsParseType();\n  }\n  if (eat(tt.eq)) {\n    tsParseType();\n  }\n}\n\nexport function tsTryParseTypeParameters() {\n  if (match(tt.lessThan)) {\n    tsParseTypeParameters();\n  }\n}\n\nfunction tsParseTypeParameters() {\n  const oldIsType = pushTypeContext(0);\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  while (!eat(tt.greaterThan) && !state.error) {\n    tsParseTypeParameter();\n    eat(tt.comma);\n  }\n  popTypeContext(oldIsType);\n}\n\n// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n// but here it's always false, because this is only used for types.\nfunction tsFillSignature(returnToken) {\n  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n  const returnTokenRequired = returnToken === tt.arrow;\n  tsTryParseTypeParameters();\n  expect(tt.parenL);\n  // Create a scope even though we're doing type parsing so we don't accidentally\n  // treat params as top-level bindings.\n  state.scopeDepth++;\n  tsParseBindingListForSignature(false /* isBlockScope */);\n  state.scopeDepth--;\n  if (returnTokenRequired) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  } else if (match(returnToken)) {\n    tsParseTypeOrTypePredicateAnnotation(returnToken);\n  }\n}\n\nfunction tsParseBindingListForSignature(isBlockScope) {\n  parseBindingList(tt.parenR, isBlockScope);\n}\n\nfunction tsParseTypeMemberSemicolon() {\n  if (!eat(tt.comma)) {\n    semicolon();\n  }\n}\n\nfunction tsParseSignatureMember() {\n  tsFillSignature(tt.colon);\n  tsParseTypeMemberSemicolon();\n}\n\nfunction tsIsUnambiguouslyIndexSignature() {\n  const snapshot = state.snapshot();\n  next(); // Skip '{'\n  const isIndexSignature = eat(tt.name) && match(tt.colon);\n  state.restoreFromSnapshot(snapshot);\n  return isIndexSignature;\n}\n\nfunction tsTryParseIndexSignature() {\n  if (!(match(tt.bracketL) && tsIsUnambiguouslyIndexSignature())) {\n    return false;\n  }\n\n  const oldIsType = pushTypeContext(0);\n\n  expect(tt.bracketL);\n  parseIdentifier();\n  tsParseTypeAnnotation();\n  expect(tt.bracketR);\n\n  tsTryParseTypeAnnotation();\n  tsParseTypeMemberSemicolon();\n\n  popTypeContext(oldIsType);\n  return true;\n}\n\nfunction tsParsePropertyOrMethodSignature(isReadonly) {\n  eat(tt.question);\n\n  if (!isReadonly && (match(tt.parenL) || match(tt.lessThan))) {\n    tsFillSignature(tt.colon);\n    tsParseTypeMemberSemicolon();\n  } else {\n    tsTryParseTypeAnnotation();\n    tsParseTypeMemberSemicolon();\n  }\n}\n\nfunction tsParseTypeMember() {\n  if (match(tt.parenL) || match(tt.lessThan)) {\n    // call signature\n    tsParseSignatureMember();\n    return;\n  }\n  if (match(tt._new)) {\n    next();\n    if (match(tt.parenL) || match(tt.lessThan)) {\n      // constructor signature\n      tsParseSignatureMember();\n    } else {\n      tsParsePropertyOrMethodSignature(false);\n    }\n    return;\n  }\n  const readonly = !!tsParseModifier([ContextualKeyword._readonly]);\n\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    return;\n  }\n  if (\n    (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) &&\n    tsNextTokenCanFollowModifier()\n  ) {\n    // This is a getter/setter on a type. The tsNextTokenCanFollowModifier\n    // function already called next() for us, so continue parsing the name.\n  }\n  parsePropertyName(-1 /* Types don't need context IDs. */);\n  tsParsePropertyOrMethodSignature(readonly);\n}\n\nfunction tsParseTypeLiteral() {\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseObjectTypeMembers() {\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseTypeMember();\n  }\n}\n\nfunction tsLookaheadIsStartOfMappedType() {\n  const snapshot = state.snapshot();\n  const isStartOfMappedType = tsIsStartOfMappedType();\n  state.restoreFromSnapshot(snapshot);\n  return isStartOfMappedType;\n}\n\nfunction tsIsStartOfMappedType() {\n  next();\n  if (eat(tt.plus) || eat(tt.minus)) {\n    return isContextual(ContextualKeyword._readonly);\n  }\n  if (isContextual(ContextualKeyword._readonly)) {\n    next();\n  }\n  if (!match(tt.bracketL)) {\n    return false;\n  }\n  next();\n  if (!tsIsIdentifier()) {\n    return false;\n  }\n  next();\n  return match(tt._in);\n}\n\nfunction tsParseMappedTypeParameter() {\n  parseIdentifier();\n  expect(tt._in);\n  tsParseType();\n}\n\nfunction tsParseMappedType() {\n  expect(tt.braceL);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expectContextual(ContextualKeyword._readonly);\n  } else {\n    eatContextual(ContextualKeyword._readonly);\n  }\n  expect(tt.bracketL);\n  tsParseMappedTypeParameter();\n  if (eatContextual(ContextualKeyword._as)) {\n    tsParseType();\n  }\n  expect(tt.bracketR);\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    expect(tt.question);\n  } else {\n    eat(tt.question);\n  }\n  tsTryParseType();\n  semicolon();\n  expect(tt.braceR);\n}\n\nfunction tsParseTupleType() {\n  expect(tt.bracketL);\n  while (!eat(tt.bracketR) && !state.error) {\n    // Do not validate presence of either none or only labeled elements\n    tsParseTupleElementType();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseTupleElementType() {\n  // parses `...TsType[]`\n  if (eat(tt.ellipsis)) {\n    tsParseType();\n  } else {\n    // parses `TsType?`\n    tsParseType();\n    eat(tt.question);\n  }\n\n  // The type we parsed above was actually a label\n  if (eat(tt.colon)) {\n    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here\n    tsParseType();\n  }\n}\n\nfunction tsParseParenthesizedType() {\n  expect(tt.parenL);\n  tsParseType();\n  expect(tt.parenR);\n}\n\nfunction tsParseTemplateLiteralType() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    tsParseType();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\nvar FunctionType; (function (FunctionType) {\n  const TSFunctionType = 0; FunctionType[FunctionType[\"TSFunctionType\"] = TSFunctionType] = \"TSFunctionType\";\n  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType[\"TSConstructorType\"] = TSConstructorType] = \"TSConstructorType\";\n  const TSAbstractConstructorType = TSConstructorType + 1; FunctionType[FunctionType[\"TSAbstractConstructorType\"] = TSAbstractConstructorType] = \"TSAbstractConstructorType\";\n})(FunctionType || (FunctionType = {}));\n\nfunction tsParseFunctionOrConstructorType(type) {\n  if (type === FunctionType.TSAbstractConstructorType) {\n    expectContextual(ContextualKeyword._abstract);\n  }\n  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {\n    expect(tt._new);\n  }\n  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n  state.inDisallowConditionalTypesContext = false;\n  tsFillSignature(tt.arrow);\n  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n}\n\nfunction tsParseNonArrayType() {\n  switch (state.type) {\n    case tt.name:\n      tsParseTypeReference();\n      return;\n    case tt._void:\n    case tt._null:\n      next();\n      return;\n    case tt.string:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt._true:\n    case tt._false:\n      parseLiteral();\n      return;\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n    case tt._this: {\n      tsParseThisTypeNode();\n      if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n        tsParseThisTypePredicate();\n      }\n      return;\n    }\n    case tt._typeof:\n      tsParseTypeQuery();\n      return;\n    case tt._import:\n      tsParseImportType();\n      return;\n    case tt.braceL:\n      if (tsLookaheadIsStartOfMappedType()) {\n        tsParseMappedType();\n      } else {\n        tsParseTypeLiteral();\n      }\n      return;\n    case tt.bracketL:\n      tsParseTupleType();\n      return;\n    case tt.parenL:\n      tsParseParenthesizedType();\n      return;\n    case tt.backQuote:\n      tsParseTemplateLiteralType();\n      return;\n    default:\n      if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n      break;\n  }\n\n  unexpected();\n}\n\nfunction tsParseArrayTypeOrHigher() {\n  tsParseNonArrayType();\n  while (!hasPrecedingLineBreak() && eat(tt.bracketL)) {\n    if (!eat(tt.bracketR)) {\n      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.\n      tsParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\n\nfunction tsParseInferType() {\n  expectContextual(ContextualKeyword._infer);\n  parseIdentifier();\n  if (match(tt._extends)) {\n    // Infer type constraints introduce an ambiguity about whether the \"extends\"\n    // is a constraint for this infer type or is another conditional type.\n    const snapshot = state.snapshot();\n    expect(tt._extends);\n    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n    state.inDisallowConditionalTypesContext = true;\n    tsParseType();\n    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    if (state.error || (!state.inDisallowConditionalTypesContext && match(tt.question))) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\nfunction tsParseTypeOperatorOrHigher() {\n  if (\n    isContextual(ContextualKeyword._keyof) ||\n    isContextual(ContextualKeyword._unique) ||\n    isContextual(ContextualKeyword._readonly)\n  ) {\n    next();\n    tsParseTypeOperatorOrHigher();\n  } else if (isContextual(ContextualKeyword._infer)) {\n    tsParseInferType();\n  } else {\n    const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n    state.inDisallowConditionalTypesContext = false;\n    tsParseArrayTypeOrHigher();\n    state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n  }\n}\n\nfunction tsParseIntersectionTypeOrHigher() {\n  eat(tt.bitwiseAND);\n  tsParseTypeOperatorOrHigher();\n  if (match(tt.bitwiseAND)) {\n    while (eat(tt.bitwiseAND)) {\n      tsParseTypeOperatorOrHigher();\n    }\n  }\n}\n\nfunction tsParseUnionTypeOrHigher() {\n  eat(tt.bitwiseOR);\n  tsParseIntersectionTypeOrHigher();\n  if (match(tt.bitwiseOR)) {\n    while (eat(tt.bitwiseOR)) {\n      tsParseIntersectionTypeOrHigher();\n    }\n  }\n}\n\nfunction tsIsStartOfFunctionType() {\n  if (match(tt.lessThan)) {\n    return true;\n  }\n  return match(tt.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();\n}\n\nfunction tsSkipParameterStart() {\n  if (match(tt.name) || match(tt._this)) {\n    next();\n    return true;\n  }\n  // If this is a possible array/object destructure, walk to the matching bracket/brace.\n  // The next token after will tell us definitively whether this is a function param.\n  if (match(tt.braceL) || match(tt.bracketL)) {\n    let depth = 1;\n    next();\n    while (depth > 0 && !state.error) {\n      if (match(tt.braceL) || match(tt.bracketL)) {\n        depth++;\n      } else if (match(tt.braceR) || match(tt.bracketR)) {\n        depth--;\n      }\n      next();\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction tsLookaheadIsUnambiguouslyStartOfFunctionType() {\n  const snapshot = state.snapshot();\n  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();\n  state.restoreFromSnapshot(snapshot);\n  return isUnambiguouslyStartOfFunctionType;\n}\n\nfunction tsIsUnambiguouslyStartOfFunctionType() {\n  next();\n  if (match(tt.parenR) || match(tt.ellipsis)) {\n    // ( )\n    // ( ...\n    return true;\n  }\n  if (tsSkipParameterStart()) {\n    if (match(tt.colon) || match(tt.comma) || match(tt.question) || match(tt.eq)) {\n      // ( xxx :\n      // ( xxx ,\n      // ( xxx ?\n      // ( xxx =\n      return true;\n    }\n    if (match(tt.parenR)) {\n      next();\n      if (match(tt.arrow)) {\n        // ( xxx ) =>\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction tsParseTypeOrTypePredicateAnnotation(returnToken) {\n  const oldIsType = pushTypeContext(0);\n  expect(returnToken);\n  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();\n  if (!finishedReturn) {\n    tsParseType();\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction tsTryParseTypeOrTypePredicateAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n}\n\nexport function tsTryParseTypeAnnotation() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\nfunction tsTryParseType() {\n  if (eat(tt.colon)) {\n    tsParseType();\n  }\n}\n\n/**\n * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,\n * `asserts this is T`.\n *\n * Returns true if we parsed the return type, false if there's still a type to be parsed.\n */\nfunction tsParseTypePredicateOrAssertsPrefix() {\n  const snapshot = state.snapshot();\n  if (isContextual(ContextualKeyword._asserts)) {\n    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-\n    // defined type guard on the `asserts` variable) or just a type called `asserts`.\n    next();\n    if (eatContextual(ContextualKeyword._is)) {\n      // If we see `asserts is`, then this must be of the form `asserts is T`, since\n      // `asserts is is T` isn't valid.\n      tsParseType();\n      return true;\n    } else if (tsIsIdentifier() || match(tt._this)) {\n      next();\n      if (eatContextual(ContextualKeyword._is)) {\n        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.\n        tsParseType();\n      }\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (tsIsIdentifier() || match(tt._this)) {\n    // This is a regular identifier, which may or may not have \"is\" after it.\n    next();\n    if (isContextual(ContextualKeyword._is) && !hasPrecedingLineBreak()) {\n      next();\n      tsParseType();\n      return true;\n    } else {\n      // Regular type, so bail out and start type parsing from scratch.\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function tsParseTypeAnnotation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  tsParseType();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseType() {\n  tsParseNonConditionalType();\n  if (state.inDisallowConditionalTypesContext || hasPrecedingLineBreak() || !eat(tt._extends)) {\n    return;\n  }\n  // extends type\n  const oldInDisallowConditionalTypesContext = state.inDisallowConditionalTypesContext;\n  state.inDisallowConditionalTypesContext = true;\n  tsParseNonConditionalType();\n  state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n\n  expect(tt.question);\n  // true type\n  tsParseType();\n  expect(tt.colon);\n  // false type\n  tsParseType();\n}\n\nfunction isAbstractConstructorSignature() {\n  return isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._new;\n}\n\nexport function tsParseNonConditionalType() {\n  if (tsIsStartOfFunctionType()) {\n    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);\n    return;\n  }\n  if (match(tt._new)) {\n    // As in `new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);\n    return;\n  } else if (isAbstractConstructorSignature()) {\n    // As in `abstract new () => Date`\n    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);\n    return;\n  }\n  tsParseUnionTypeOrHigher();\n}\n\nexport function tsParseTypeAssertion() {\n  const oldIsType = pushTypeContext(1);\n  tsParseType();\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n  parseMaybeUnary();\n}\n\nexport function tsTryParseJSXTypeArgument() {\n  if (eat(tt.jsxTagStart)) {\n    state.tokens[state.tokens.length - 1].type = tt.typeParameterStart;\n    const oldIsType = pushTypeContext(1);\n    while (!match(tt.greaterThan) && !state.error) {\n      tsParseType();\n      eat(tt.comma);\n    }\n    // Process >, but the one after needs to be parsed JSX-style.\n    nextJSXTagToken();\n    popTypeContext(oldIsType);\n  }\n}\n\nfunction tsParseHeritageClause() {\n  while (!match(tt.braceL) && !state.error) {\n    tsParseExpressionWithTypeArguments();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseExpressionWithTypeArguments() {\n  // Note: TS uses parseLeftHandSideExpressionOrHigher,\n  // then has grammar errors later if it's not an EntityName.\n  tsParseEntityName();\n  if (match(tt.lessThan)) {\n    tsParseTypeArguments();\n  }\n}\n\nfunction tsParseInterfaceDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  if (eat(tt._extends)) {\n    tsParseHeritageClause();\n  }\n  tsParseObjectTypeMembers();\n}\n\nfunction tsParseTypeAliasDeclaration() {\n  parseBindingIdentifier(false);\n  tsTryParseTypeParameters();\n  expect(tt.eq);\n  tsParseType();\n  semicolon();\n}\n\nfunction tsParseEnumMember() {\n  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n  if (match(tt.string)) {\n    parseLiteral();\n  } else {\n    parseIdentifier();\n  }\n  if (eat(tt.eq)) {\n    const eqIndex = state.tokens.length - 1;\n    parseMaybeAssign();\n    state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n  }\n}\n\nfunction tsParseEnumDeclaration() {\n  parseBindingIdentifier(false);\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    tsParseEnumMember();\n    eat(tt.comma);\n  }\n}\n\nfunction tsParseModuleBlock() {\n  expect(tt.braceL);\n  parseBlockBody(/* end */ tt.braceR);\n}\n\nfunction tsParseModuleOrNamespaceDeclaration() {\n  parseBindingIdentifier(false);\n  if (eat(tt.dot)) {\n    tsParseModuleOrNamespaceDeclaration();\n  } else {\n    tsParseModuleBlock();\n  }\n}\n\nfunction tsParseAmbientExternalModuleDeclaration() {\n  if (isContextual(ContextualKeyword._global)) {\n    parseIdentifier();\n  } else if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    unexpected();\n  }\n\n  if (match(tt.braceL)) {\n    tsParseModuleBlock();\n  } else {\n    semicolon();\n  }\n}\n\nexport function tsParseImportEqualsDeclaration() {\n  parseImportedIdentifier();\n  expect(tt.eq);\n  tsParseModuleReference();\n  semicolon();\n}\n\nfunction tsIsExternalModuleReference() {\n  return isContextual(ContextualKeyword._require) && lookaheadType() === tt.parenL;\n}\n\nfunction tsParseModuleReference() {\n  if (tsIsExternalModuleReference()) {\n    tsParseExternalModuleReference();\n  } else {\n    tsParseEntityName();\n  }\n}\n\nfunction tsParseExternalModuleReference() {\n  expectContextual(ContextualKeyword._require);\n  expect(tt.parenL);\n  if (!match(tt.string)) {\n    unexpected();\n  }\n  parseLiteral();\n  expect(tt.parenR);\n}\n\n// Utilities\n\n// Returns true if a statement matched.\nfunction tsTryParseDeclare() {\n  if (isLineTerminator()) {\n    return false;\n  }\n  switch (state.type) {\n    case tt._function: {\n      const oldIsType = pushTypeContext(1);\n      next();\n      // We don't need to precisely get the function start here, since it's only used to mark\n      // the function as a type if it's bodiless, and it's already a type here.\n      const functionStart = state.start;\n      parseFunction(functionStart, /* isStatement */ true);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._class: {\n      const oldIsType = pushTypeContext(1);\n      parseClass(/* isStatement */ true, /* optionalId */ false);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt._const: {\n      if (match(tt._const) && isLookaheadContextual(ContextualKeyword._enum)) {\n        const oldIsType = pushTypeContext(1);\n        // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n        expect(tt._const);\n        expectContextual(ContextualKeyword._enum);\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n    }\n    // falls through\n    case tt._var:\n    case tt._let: {\n      const oldIsType = pushTypeContext(1);\n      parseVarStatement(state.type !== tt._var);\n      popTypeContext(oldIsType);\n      return true;\n    }\n    case tt.name: {\n      const oldIsType = pushTypeContext(1);\n      const contextualKeyword = state.contextualKeyword;\n      let matched = false;\n      if (contextualKeyword === ContextualKeyword._global) {\n        tsParseAmbientExternalModuleDeclaration();\n        matched = true;\n      } else {\n        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);\n      }\n      popTypeContext(oldIsType);\n      return matched;\n    }\n    default:\n      return false;\n  }\n}\n\n// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n// Returns true if it matched a declaration.\nfunction tsTryParseExportDeclaration() {\n  return tsParseDeclaration(state.contextualKeyword, /* isBeforeToken */ true);\n}\n\n// Returns true if it matched a statement.\nfunction tsParseExpressionStatement(contextualKeyword) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._declare: {\n      const declareTokenIndex = state.tokens.length - 1;\n      const matched = tsTryParseDeclare();\n      if (matched) {\n        state.tokens[declareTokenIndex].type = tt._declare;\n        return true;\n      }\n      break;\n    }\n    case ContextualKeyword._global:\n      // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n      if (match(tt.braceL)) {\n        tsParseModuleBlock();\n        return true;\n      }\n      break;\n\n    default:\n      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);\n  }\n  return false;\n}\n\n/**\n * Common code for parsing a declaration.\n *\n * isBeforeToken indicates that the current parser state is at the contextual\n * keyword (and that it is not yet emitted) rather than reading the token after\n * it. When isBeforeToken is true, we may be preceded by an `export` token and\n * should include that token in a type context we create, e.g. to handle\n * `export interface` or `export type`. (This is a bit of a hack and should be\n * cleaned up at some point.)\n *\n * Returns true if it matched a declaration.\n */\nfunction tsParseDeclaration(contextualKeyword, isBeforeToken) {\n  switch (contextualKeyword) {\n    case ContextualKeyword._abstract:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt._class)) {\n        state.tokens[state.tokens.length - 1].type = tt._abstract;\n        parseClass(/* isStatement */ true, /* optionalId */ false);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._enum:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        state.tokens[state.tokens.length - 1].type = tt._enum;\n        tsParseEnumDeclaration();\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._interface:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        // `next` is true in \"export\" and \"declare\" contexts, so we want to remove that token\n        // as well.\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseInterfaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._module:\n      if (tsCheckLineTerminator(isBeforeToken)) {\n        if (match(tt.string)) {\n          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n          tsParseAmbientExternalModuleDeclaration();\n          popTypeContext(oldIsType);\n          return true;\n        } else if (match(tt.name)) {\n          const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n          tsParseModuleOrNamespaceDeclaration();\n          popTypeContext(oldIsType);\n          return true;\n        }\n      }\n      break;\n\n    case ContextualKeyword._namespace:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseModuleOrNamespaceDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    case ContextualKeyword._type:\n      if (tsCheckLineTerminator(isBeforeToken) && match(tt.name)) {\n        const oldIsType = pushTypeContext(isBeforeToken ? 2 : 1);\n        tsParseTypeAliasDeclaration();\n        popTypeContext(oldIsType);\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n  return false;\n}\n\nfunction tsCheckLineTerminator(isBeforeToken) {\n  if (isBeforeToken) {\n    // Babel checks hasFollowingLineBreak here and returns false, but this\n    // doesn't actually come up, e.g. `export interface` can never be on its own\n    // line in valid code.\n    next();\n    return true;\n  } else {\n    return !isLineTerminator();\n  }\n}\n\n// Returns true if there was a generic async arrow function.\nfunction tsTryParseGenericAsyncArrowFunction() {\n  const snapshot = state.snapshot();\n\n  tsParseTypeParameters();\n  parseFunctionParams();\n  tsTryParseTypeOrTypePredicateAnnotation();\n  expect(tt.arrow);\n\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n\n  parseFunctionBody(true);\n  return true;\n}\n\n/**\n * If necessary, hack the tokenizer state so that this bitshift was actually a\n * less-than token, then keep parsing. This should only be used in situations\n * where we restore from snapshot on error (which reverts this change) or\n * where bitshift would be illegal anyway (e.g. in a class \"extends\" clause).\n *\n * This hack is useful to handle situations like foo<<T>() => void>() where\n * there can legitimately be two open-angle-brackets in a row in TS.\n */\nfunction tsParseTypeArgumentsWithPossibleBitshift() {\n  if (state.type === tt.bitShiftL) {\n    state.pos -= 1;\n    finishToken(tt.lessThan);\n  }\n  tsParseTypeArguments();\n}\n\nfunction tsParseTypeArguments() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    tsParseType();\n    eat(tt.comma);\n  }\n  if (!oldIsType) {\n    // If the type arguments are present in an expression context, e.g.\n    // f<number>(), then the > sign should be tokenized as a non-type token.\n    // In particular, f(a < b, c >= d) should parse the >= as a single token,\n    // resulting in a syntax error and fallback to the non-type-args\n    // interpretation. In the success case, even though the > is tokenized as a\n    // non-type token, it still must be marked as a type token so that it is\n    // erased.\n    popTypeContext(oldIsType);\n    rescan_gt();\n    expect(tt.greaterThan);\n    state.tokens[state.tokens.length - 1].isType = true;\n  } else {\n    expect(tt.greaterThan);\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function tsIsDeclarationStart() {\n  if (match(tt.name)) {\n    switch (state.contextualKeyword) {\n      case ContextualKeyword._abstract:\n      case ContextualKeyword._declare:\n      case ContextualKeyword._enum:\n      case ContextualKeyword._interface:\n      case ContextualKeyword._module:\n      case ContextualKeyword._namespace:\n      case ContextualKeyword._type:\n        return true;\n      default:\n        break;\n    }\n  }\n\n  return false;\n}\n\n// ======================================================\n// OVERRIDES\n// ======================================================\n\nexport function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n  }\n\n  // The original code checked the node type to make sure this function type allows a missing\n  // body, but we skip that to avoid sending around the node type. We instead just use the\n  // allowExpressionBody boolean to make sure it's not an arrow function.\n  if (!match(tt.braceL) && isLineTerminator()) {\n    // Retroactively mark the function declaration as a type.\n    let i = state.tokens.length - 1;\n    while (\n      i >= 0 &&\n      (state.tokens[i].start >= functionStart ||\n        state.tokens[i].type === tt._default ||\n        state.tokens[i].type === tt._export)\n    ) {\n      state.tokens[i].isType = true;\n      i--;\n    }\n    return;\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function tsParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!hasPrecedingLineBreak() && eat(tt.bang)) {\n    state.tokens[state.tokens.length - 1].type = tt.nonNullAssertion;\n    return;\n  }\n\n  if (match(tt.lessThan) || match(tt.bitShiftL)) {\n    // There are number of things we are going to \"maybe\" parse, like type arguments on\n    // tagged template expressions. If any of them fail, walk it back and continue.\n    const snapshot = state.snapshot();\n\n    if (!noCalls && atPossibleAsync()) {\n      // Almost certainly this is a generic async function `async <T>() => ...\n      // But it might be a call with a type argument `async<T>();`\n      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();\n      if (asyncArrowFn) {\n        return;\n      }\n    }\n    tsParseTypeArgumentsWithPossibleBitshift();\n    if (!noCalls && eat(tt.parenL)) {\n      // With f<T>(), the subscriptStartIndex marker is on the ( token.\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      parseCallExpressionArguments();\n    } else if (match(tt.backQuote)) {\n      // Tagged template with a type argument.\n      parseTemplate();\n    } else if (\n      // The remaining possible case is an instantiation expression, e.g.\n      // Array<number> . Check for a few cases that would disqualify it and\n      // cause us to bail out.\n      // a<b>>c is not (a<b>)>c, but a<(b>>c)\n      state.type === tt.greaterThan ||\n      // a<b>c is (a<b)>c\n      (state.type !== tt.parenL &&\n        Boolean(state.type & TokenType.IS_EXPRESSION_START) &&\n        !hasPrecedingLineBreak())\n    ) {\n      // Bail out. We have something like a<b>c, which is not an expression with\n      // type arguments but an (a < b) > c comparison.\n      unexpected();\n    }\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  } else if (!noCalls && match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    // If we see f?.<, then this must be an optional call with a type argument.\n    next();\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    tsParseTypeArguments();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function tsTryParseExport() {\n  if (eat(tt._import)) {\n    // One of these cases:\n    // export import A = B;\n    // export import type A = require(\"A\");\n    if (isContextual(ContextualKeyword._type) && lookaheadType() !== tt.eq) {\n      // Eat a `type` token, unless it's actually an identifier name.\n      expectContextual(ContextualKeyword._type);\n    }\n    tsParseImportEqualsDeclaration();\n    return true;\n  } else if (eat(tt.eq)) {\n    // `export = x;`\n    parseExpression();\n    semicolon();\n    return true;\n  } else if (eatContextual(ContextualKeyword._as)) {\n    // `export as namespace A;`\n    // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n    expectContextual(ContextualKeyword._namespace);\n    parseIdentifier();\n    semicolon();\n    return true;\n  } else {\n    if (isContextual(ContextualKeyword._type)) {\n      const nextType = lookaheadType();\n      // export type {foo} from 'a';\n      // export type * from 'a';'\n      // export type * as ns from 'a';'\n      if (nextType === tt.braceL || nextType === tt.star) {\n        next();\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Parse a TS import specifier, which may be prefixed with \"type\" and may be of\n * the form `foo as bar`.\n *\n * The number of identifier-like tokens we see happens to be enough to uniquely\n * identify the form, so simply count the number of identifiers rather than\n * matching the words `type` or `as`. This is particularly important because\n * `type` and `as` could each actually be plain identifiers rather than\n * keywords.\n */\nexport function tsParseImportSpecifier() {\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {type foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    state.tokens[state.tokens.length - 2].isType = true;\n    state.tokens[state.tokens.length - 1].isType = true;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // import {foo as bar}\n    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n    return;\n  }\n  parseIdentifier();\n  // import {type foo as bar}\n  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ImportAccess;\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n  state.tokens[state.tokens.length - 4].isType = true;\n  state.tokens[state.tokens.length - 3].isType = true;\n  state.tokens[state.tokens.length - 2].isType = true;\n  state.tokens[state.tokens.length - 1].isType = true;\n}\n\n/**\n * Just like named import specifiers, export specifiers can have from 1 to 4\n * tokens, inclusive, and the number of tokens determines the role of each token.\n */\nexport function tsParseExportSpecifier() {\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {type foo}\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n    state.tokens[state.tokens.length - 2].isType = true;\n    state.tokens[state.tokens.length - 1].isType = true;\n    return;\n  }\n  parseIdentifier();\n  if (match(tt.comma) || match(tt.braceR)) {\n    // export {foo as bar}\n    state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;\n    return;\n  }\n  parseIdentifier();\n  // export {type foo as bar}\n  state.tokens[state.tokens.length - 3].identifierRole = IdentifierRole.ExportAccess;\n  state.tokens[state.tokens.length - 4].isType = true;\n  state.tokens[state.tokens.length - 3].isType = true;\n  state.tokens[state.tokens.length - 2].isType = true;\n  state.tokens[state.tokens.length - 1].isType = true;\n}\n\nexport function tsTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._abstract) && lookaheadType() === tt._class) {\n    state.type = tt._abstract;\n    next(); // Skip \"abstract\"\n    parseClass(true, true);\n    return true;\n  }\n  if (isContextual(ContextualKeyword._interface)) {\n    // Make sure \"export default\" are considered type tokens so the whole thing is removed.\n    const oldIsType = pushTypeContext(2);\n    tsParseDeclaration(ContextualKeyword._interface, true);\n    popTypeContext(oldIsType);\n    return true;\n  }\n  return false;\n}\n\nexport function tsTryParseStatementContent() {\n  if (state.type === tt._const) {\n    const ahead = lookaheadTypeAndKeyword();\n    if (ahead.type === tt.name && ahead.contextualKeyword === ContextualKeyword._enum) {\n      expect(tt._const);\n      expectContextual(ContextualKeyword._enum);\n      state.tokens[state.tokens.length - 1].type = tt._enum;\n      tsParseEnumDeclaration();\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function tsTryParseClassMemberWithIsStatic(isStatic) {\n  const memberStartIndexAfterStatic = state.tokens.length;\n  tsParseModifiers([\n    ContextualKeyword._abstract,\n    ContextualKeyword._readonly,\n    ContextualKeyword._declare,\n    ContextualKeyword._static,\n    ContextualKeyword._override,\n  ]);\n\n  const modifiersEndIndex = state.tokens.length;\n  const found = tsTryParseIndexSignature();\n  if (found) {\n    // Index signatures are type declarations, so set the modifier tokens as\n    // type tokens. Most tokens could be assumed to be type tokens, but `static`\n    // is ambiguous unless we set it explicitly here.\n    const memberStartIndex = isStatic\n      ? memberStartIndexAfterStatic - 1\n      : memberStartIndexAfterStatic;\n    for (let i = memberStartIndex; i < modifiersEndIndex; i++) {\n      state.tokens[i].isType = true;\n    }\n    return true;\n  }\n  return false;\n}\n\n// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`\n// is that e.g. `type()` is valid JS, so we must try parsing that first.\n// If it's really a type, we will parse `type` as the statement, and can correct it here\n// by parsing the rest.\nexport function tsParseIdentifierStatement(contextualKeyword) {\n  const matched = tsParseExpressionStatement(contextualKeyword);\n  if (!matched) {\n    semicolon();\n  }\n}\n\nexport function tsParseExportDeclaration() {\n  // \"export declare\" is equivalent to just \"export\".\n  const isDeclare = eatContextual(ContextualKeyword._declare);\n  if (isDeclare) {\n    state.tokens[state.tokens.length - 1].type = tt._declare;\n  }\n\n  let matchedDeclaration = false;\n  if (match(tt.name)) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      matchedDeclaration = tsTryParseExportDeclaration();\n      popTypeContext(oldIsType);\n    } else {\n      matchedDeclaration = tsTryParseExportDeclaration();\n    }\n  }\n  if (!matchedDeclaration) {\n    if (isDeclare) {\n      const oldIsType = pushTypeContext(2);\n      parseStatement(true);\n      popTypeContext(oldIsType);\n    } else {\n      parseStatement(true);\n    }\n  }\n}\n\nexport function tsAfterParseClassSuper(hasSuper) {\n  if (hasSuper && (match(tt.lessThan) || match(tt.bitShiftL))) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  if (eatContextual(ContextualKeyword._implements)) {\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    const oldIsType = pushTypeContext(1);\n    tsParseHeritageClause();\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function tsStartParseObjPropValue() {\n  tsTryParseTypeParameters();\n}\n\nexport function tsStartParseFunctionParams() {\n  tsTryParseTypeParameters();\n}\n\n// `let x: number;`\nexport function tsAfterParseVarHead() {\n  const oldIsType = pushTypeContext(0);\n  if (!hasPrecedingLineBreak()) {\n    eat(tt.bang);\n  }\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function tsStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    tsParseTypeAnnotation();\n  }\n}\n\n// Returns true if the expression was an arrow function.\nexport function tsParseMaybeAssign(noIn, isWithinParens) {\n  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n  if (isJSXEnabled) {\n    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);\n  } else {\n    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);\n  }\n}\n\nexport function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  // Prefer to parse JSX if possible. But may be an arrow fn.\n  const snapshot = state.snapshot();\n  let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Otherwise, try as type-parameterized arrow function.\n  state.type = tt.typeParameterStart;\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n\n  return wasArrow;\n}\n\nexport function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {\n  if (!match(tt.lessThan)) {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n\n  const snapshot = state.snapshot();\n  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n  tsParseTypeParameters();\n  const wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n  if (!wasArrow) {\n    unexpected();\n  }\n  if (state.error) {\n    state.restoreFromSnapshot(snapshot);\n  } else {\n    return wasArrow;\n  }\n\n  // Try parsing a type cast instead of an arrow function.\n  // This will start with a type assertion (via parseMaybeUnary).\n  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\nexport function tsParseArrow() {\n  if (match(tt.colon)) {\n    // This is different from how the TS parser does it.\n    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.\n    const snapshot = state.snapshot();\n\n    tsParseTypeOrTypePredicateAnnotation(tt.colon);\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n  return eat(tt.arrow);\n}\n\n// Allow type annotations inside of a parameter list.\nexport function tsParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  tsTryParseTypeAnnotation();\n  popTypeContext(oldIsType);\n}\n\nexport function tsParseMaybeDecoratorArguments() {\n  if (match(tt.lessThan) || match(tt.bitShiftL)) {\n    tsParseTypeArgumentsWithPossibleBitshift();\n  }\n  baseParseMaybeDecoratorArguments();\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2495, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/plugins/jsx/index.js"],"sourcesContent":["import {\n  eat,\n  finishToken,\n  getTokenFromCode,\n  IdentifierRole,\n  JSXRole,\n  match,\n  next,\n  skipSpace,\n  Token,\n} from \"../../tokenizer/index\";\nimport {TokenType as tt} from \"../../tokenizer/types\";\nimport {input, isTypeScriptEnabled, state} from \"../../traverser/base\";\nimport {parseExpression, parseMaybeAssign} from \"../../traverser/expression\";\nimport {expect, unexpected} from \"../../traverser/util\";\nimport {charCodes} from \"../../util/charcodes\";\nimport {IS_IDENTIFIER_CHAR, IS_IDENTIFIER_START} from \"../../util/identifier\";\nimport {tsTryParseJSXTypeArgument} from \"../typescript\";\n\n/**\n * Read token with JSX contents.\n *\n * In addition to detecting jsxTagStart and also regular tokens that might be\n * part of an expression, this code detects the start and end of text ranges\n * within JSX children. In order to properly count the number of children, we\n * distinguish jsxText from jsxEmptyText, which is a text range that simplifies\n * to the empty string after JSX whitespace trimming.\n *\n * It turns out that a JSX text range will simplify to the empty string if and\n * only if both of these conditions hold:\n * - The range consists entirely of whitespace characters (only counting space,\n *   tab, \\r, and \\n).\n * - The range has at least one newline.\n * This can be proven by analyzing any implementation of whitespace trimming,\n * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.\n */\nfunction jsxReadToken() {\n  let sawNewline = false;\n  let sawNonWhitespace = false;\n  while (true) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated JSX contents\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n    if (ch === charCodes.lessThan || ch === charCodes.leftCurlyBrace) {\n      if (state.pos === state.start) {\n        if (ch === charCodes.lessThan) {\n          state.pos++;\n          finishToken(tt.jsxTagStart);\n          return;\n        }\n        getTokenFromCode(ch);\n        return;\n      }\n      if (sawNewline && !sawNonWhitespace) {\n        finishToken(tt.jsxEmptyText);\n      } else {\n        finishToken(tt.jsxText);\n      }\n      return;\n    }\n\n    // This is part of JSX text.\n    if (ch === charCodes.lineFeed) {\n      sawNewline = true;\n    } else if (ch !== charCodes.space && ch !== charCodes.carriageReturn && ch !== charCodes.tab) {\n      sawNonWhitespace = true;\n    }\n    state.pos++;\n  }\n}\n\nfunction jsxReadString(quote) {\n  state.pos++;\n  for (;;) {\n    if (state.pos >= input.length) {\n      unexpected(\"Unterminated string constant\");\n      return;\n    }\n\n    const ch = input.charCodeAt(state.pos);\n    if (ch === quote) {\n      state.pos++;\n      break;\n    }\n    state.pos++;\n  }\n  finishToken(tt.string);\n}\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can't contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\nfunction jsxReadWord() {\n  let ch;\n  do {\n    if (state.pos > input.length) {\n      unexpected(\"Unexpectedly reached the end of input.\");\n      return;\n    }\n    ch = input.charCodeAt(++state.pos);\n  } while (IS_IDENTIFIER_CHAR[ch] || ch === charCodes.dash);\n  finishToken(tt.jsxName);\n}\n\n// Parse next token as JSX identifier\nfunction jsxParseIdentifier() {\n  nextJSXTagToken();\n}\n\n// Parse namespaced identifier.\nfunction jsxParseNamespacedName(identifierRole) {\n  jsxParseIdentifier();\n  if (!eat(tt.colon)) {\n    // Plain identifier, so this is an access.\n    state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n    return;\n  }\n  // Process the second half of the namespaced name.\n  jsxParseIdentifier();\n}\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\nfunction jsxParseElementName() {\n  const firstTokenIndex = state.tokens.length;\n  jsxParseNamespacedName(IdentifierRole.Access);\n  let hadDot = false;\n  while (match(tt.dot)) {\n    hadDot = true;\n    nextJSXTagToken();\n    jsxParseIdentifier();\n  }\n  // For tags like <div> with a lowercase letter and no dots, the name is\n  // actually *not* an identifier access, since it's referring to a built-in\n  // tag name. Remove the identifier role in this case so that it's not\n  // accidentally transformed by the imports transform when preserving JSX.\n  if (!hadDot) {\n    const firstToken = state.tokens[firstTokenIndex];\n    const firstChar = input.charCodeAt(firstToken.start);\n    if (firstChar >= charCodes.lowercaseA && firstChar <= charCodes.lowercaseZ) {\n      firstToken.identifierRole = null;\n    }\n  }\n}\n\n// Parses any type of JSX attribute value.\nfunction jsxParseAttributeValue() {\n  switch (state.type) {\n    case tt.braceL:\n      next();\n      parseExpression();\n      nextJSXTagToken();\n      return;\n\n    case tt.jsxTagStart:\n      jsxParseElement();\n      nextJSXTagToken();\n      return;\n\n    case tt.string:\n      nextJSXTagToken();\n      return;\n\n    default:\n      unexpected(\"JSX value should be either an expression or a quoted JSX text\");\n  }\n}\n\n// Parse JSX spread child, after already processing the {\n// Does not parse the closing }\nfunction jsxParseSpreadChild() {\n  expect(tt.ellipsis);\n  parseExpression();\n}\n\n// Parses JSX opening tag starting after \"<\".\n// Returns true if the tag was self-closing.\n// Does not parse the last token.\nfunction jsxParseOpeningElement(initialTokenIndex) {\n  if (match(tt.jsxTagEnd)) {\n    // This is an open-fragment.\n    return false;\n  }\n  jsxParseElementName();\n  if (isTypeScriptEnabled) {\n    tsTryParseJSXTypeArgument();\n  }\n  let hasSeenPropSpread = false;\n  while (!match(tt.slash) && !match(tt.jsxTagEnd) && !state.error) {\n    if (eat(tt.braceL)) {\n      hasSeenPropSpread = true;\n      expect(tt.ellipsis);\n      parseMaybeAssign();\n      // }\n      nextJSXTagToken();\n      continue;\n    }\n    if (\n      hasSeenPropSpread &&\n      state.end - state.start === 3 &&\n      input.charCodeAt(state.start) === charCodes.lowercaseK &&\n      input.charCodeAt(state.start + 1) === charCodes.lowercaseE &&\n      input.charCodeAt(state.start + 2) === charCodes.lowercaseY\n    ) {\n      state.tokens[initialTokenIndex].jsxRole = JSXRole.KeyAfterPropSpread;\n    }\n    jsxParseNamespacedName(IdentifierRole.ObjectKey);\n    if (match(tt.eq)) {\n      nextJSXTagToken();\n      jsxParseAttributeValue();\n    }\n  }\n  const isSelfClosing = match(tt.slash);\n  if (isSelfClosing) {\n    // /\n    nextJSXTagToken();\n  }\n  return isSelfClosing;\n}\n\n// Parses JSX closing tag starting after \"</\".\n// Does not parse the last token.\nfunction jsxParseClosingElement() {\n  if (match(tt.jsxTagEnd)) {\n    // Fragment syntax, so we immediately have a tag end.\n    return;\n  }\n  jsxParseElementName();\n}\n\n// Parses entire JSX element, including its opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n// Does not parse the last token.\nfunction jsxParseElementAt() {\n  const initialTokenIndex = state.tokens.length - 1;\n  state.tokens[initialTokenIndex].jsxRole = JSXRole.NoChildren;\n  let numExplicitChildren = 0;\n  const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);\n  if (!isSelfClosing) {\n    nextJSXExprToken();\n    while (true) {\n      switch (state.type) {\n        case tt.jsxTagStart:\n          nextJSXTagToken();\n          if (match(tt.slash)) {\n            nextJSXTagToken();\n            jsxParseClosingElement();\n            // Key after prop spread takes precedence over number of children,\n            // since it means we switch to createElement, which doesn't care\n            // about number of children.\n            if (state.tokens[initialTokenIndex].jsxRole !== JSXRole.KeyAfterPropSpread) {\n              if (numExplicitChildren === 1) {\n                state.tokens[initialTokenIndex].jsxRole = JSXRole.OneChild;\n              } else if (numExplicitChildren > 1) {\n                state.tokens[initialTokenIndex].jsxRole = JSXRole.StaticChildren;\n              }\n            }\n            return;\n          }\n          numExplicitChildren++;\n          jsxParseElementAt();\n          nextJSXExprToken();\n          break;\n\n        case tt.jsxText:\n          numExplicitChildren++;\n          nextJSXExprToken();\n          break;\n\n        case tt.jsxEmptyText:\n          nextJSXExprToken();\n          break;\n\n        case tt.braceL:\n          next();\n          if (match(tt.ellipsis)) {\n            jsxParseSpreadChild();\n            nextJSXExprToken();\n            // Spread children are a mechanism to explicitly mark children as\n            // static, so count it as 2 children to satisfy the \"more than one\n            // child\" condition.\n            numExplicitChildren += 2;\n          } else {\n            // If we see {}, this is an empty pseudo-expression that doesn't\n            // count as a child.\n            if (!match(tt.braceR)) {\n              numExplicitChildren++;\n              parseExpression();\n            }\n            nextJSXExprToken();\n          }\n\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          unexpected();\n          return;\n      }\n    }\n  }\n}\n\n// Parses entire JSX element from current position.\n// Does not parse the last token.\nexport function jsxParseElement() {\n  nextJSXTagToken();\n  jsxParseElementAt();\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function nextJSXTagToken() {\n  state.tokens.push(new Token());\n  skipSpace();\n  state.start = state.pos;\n  const code = input.charCodeAt(state.pos);\n\n  if (IS_IDENTIFIER_START[code]) {\n    jsxReadWord();\n  } else if (code === charCodes.quotationMark || code === charCodes.apostrophe) {\n    jsxReadString(code);\n  } else {\n    // The following tokens are just one character each.\n    ++state.pos;\n    switch (code) {\n      case charCodes.greaterThan:\n        finishToken(tt.jsxTagEnd);\n        break;\n      case charCodes.lessThan:\n        finishToken(tt.jsxTagStart);\n        break;\n      case charCodes.slash:\n        finishToken(tt.slash);\n        break;\n      case charCodes.equalsTo:\n        finishToken(tt.eq);\n        break;\n      case charCodes.leftCurlyBrace:\n        finishToken(tt.braceL);\n        break;\n      case charCodes.dot:\n        finishToken(tt.dot);\n        break;\n      case charCodes.colon:\n        finishToken(tt.colon);\n        break;\n      default:\n        unexpected();\n    }\n  }\n}\n\nfunction nextJSXExprToken() {\n  state.tokens.push(new Token());\n  state.start = state.pos;\n  jsxReadToken();\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2830, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/plugins/types.js"],"sourcesContent":["import {eatTypeToken, lookaheadType, match} from \"../tokenizer/index\";\nimport {TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled} from \"../traverser/base\";\nimport {baseParseConditional} from \"../traverser/expression\";\nimport {flowParseTypeAnnotation} from \"./flow\";\nimport {tsParseTypeAnnotation} from \"./typescript\";\n\n/**\n * Common parser code for TypeScript and Flow.\n */\n\n// An apparent conditional expression could actually be an optional parameter in an arrow function.\nexport function typedParseConditional(noIn) {\n  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called\n  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional\n  // parameters without type annotations, i.e. ?, and ?) .\n  if (match(tt.question)) {\n    const nextType = lookaheadType();\n    if (nextType === tt.colon || nextType === tt.comma || nextType === tt.parenR) {\n      return;\n    }\n  }\n  baseParseConditional(noIn);\n}\n\n// Note: These \"type casts\" are *not* valid TS expressions.\n// But we parse them here and change them when completing the arrow function.\nexport function typedParseParenItem() {\n  eatTypeToken(tt.question);\n  if (match(tt.colon)) {\n    if (isTypeScriptEnabled) {\n      tsParseTypeAnnotation();\n    } else if (isFlowEnabled) {\n      flowParseTypeAnnotation();\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOO,SAAS,sBAAsB,IAAI;IACxC,+FAA+F;IAC/F,6FAA6F;IAC7F,wDAAwD;IACxD,IAAI,IAAA,6PAAK,EAAC,iQAAE,CAAC,QAAQ,GAAG;QACtB,MAAM,WAAW,IAAA,qQAAa;QAC9B,IAAI,aAAa,iQAAE,CAAC,KAAK,IAAI,aAAa,iQAAE,CAAC,KAAK,IAAI,aAAa,iQAAE,CAAC,MAAM,EAAE;YAC5E;QACF;IACF;IACA,IAAA,iRAAoB,EAAC;AACvB;AAIO,SAAS;IACd,IAAA,oQAAY,EAAC,iQAAE,CAAC,QAAQ;IACxB,IAAI,IAAA,6PAAK,EAAC,iQAAE,CAAC,KAAK,GAAG;QACnB,IAAI,0QAAmB,EAAE;YACvB,IAAA,gRAAqB;QACvB,OAAO,IAAI,oQAAa,EAAE;YACxB,IAAA,4QAAuB;QACzB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2874, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/plugins/flow.js"],"sourcesContent":["/* eslint max-len: 0 */\n\nimport {\n  eat,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {input, state} from \"../traverser/base\";\nimport {\n  baseParseMaybeAssign,\n  baseParseSubscript,\n  baseParseSubscripts,\n  parseArrow,\n  parseArrowExpression,\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseFunctionBody,\n  parseIdentifier,\n  parseLiteral,\n\n} from \"../traverser/expression\";\nimport {\n  baseParseExportStar,\n  parseExport,\n  parseExportFrom,\n  parseExportSpecifiers,\n  parseFunctionParams,\n  parseImport,\n  parseStatement,\n} from \"../traverser/statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  isContextual,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"../traverser/util\";\n\nfunction isMaybeDefaultImport(lookahead) {\n  return (\n    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&\n    lookahead.contextualKeyword !== ContextualKeyword._from\n  );\n}\n\nfunction flowParseTypeInitialiser(tok) {\n  const oldIsType = pushTypeContext(0);\n  expect(tok || tt.colon);\n  flowParseType();\n  popTypeContext(oldIsType);\n}\n\nfunction flowParsePredicate() {\n  expect(tt.modulo);\n  expectContextual(ContextualKeyword._checks);\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  }\n}\n\nfunction flowParseTypeAndPredicateInitialiser() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.colon);\n  if (match(tt.modulo)) {\n    flowParsePredicate();\n  } else {\n    flowParseType();\n    if (match(tt.modulo)) {\n      flowParsePredicate();\n    }\n  }\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseDeclareClass() {\n  next();\n  flowParseInterfaceish(/* isClass */ true);\n}\n\nfunction flowParseDeclareFunction() {\n  next();\n  parseIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  flowParseFunctionTypeParams();\n  expect(tt.parenR);\n\n  flowParseTypeAndPredicateInitialiser();\n\n  semicolon();\n}\n\nfunction flowParseDeclare() {\n  if (match(tt._class)) {\n    flowParseDeclareClass();\n  } else if (match(tt._function)) {\n    flowParseDeclareFunction();\n  } else if (match(tt._var)) {\n    flowParseDeclareVariable();\n  } else if (eatContextual(ContextualKeyword._module)) {\n    if (eat(tt.dot)) {\n      flowParseDeclareModuleExports();\n    } else {\n      flowParseDeclareModule();\n    }\n  } else if (isContextual(ContextualKeyword._type)) {\n    flowParseDeclareTypeAlias();\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    flowParseDeclareOpaqueType();\n  } else if (isContextual(ContextualKeyword._interface)) {\n    flowParseDeclareInterface();\n  } else if (match(tt._export)) {\n    flowParseDeclareExportDeclaration();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareVariable() {\n  next();\n  flowParseTypeAnnotatableIdentifier();\n  semicolon();\n}\n\nfunction flowParseDeclareModule() {\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n\n  expect(tt.braceL);\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._import)) {\n      next();\n      parseImport();\n    } else {\n      unexpected();\n    }\n  }\n  expect(tt.braceR);\n}\n\nfunction flowParseDeclareExportDeclaration() {\n  expect(tt._export);\n\n  if (eat(tt._default)) {\n    if (match(tt._function) || match(tt._class)) {\n      // declare export default class ...\n      // declare export default function ...\n      flowParseDeclare();\n    } else {\n      // declare export default [type];\n      flowParseType();\n      semicolon();\n    }\n  } else if (\n    match(tt._var) || // declare export var ...\n    match(tt._function) || // declare export function ...\n    match(tt._class) || // declare export class ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque ..\n  ) {\n    flowParseDeclare();\n  } else if (\n    match(tt.star) || // declare export * from ''\n    match(tt.braceL) || // declare export {} ...\n    isContextual(ContextualKeyword._interface) || // declare export interface ...\n    isContextual(ContextualKeyword._type) || // declare export type ...\n    isContextual(ContextualKeyword._opaque) // declare export opaque type ...\n  ) {\n    parseExport();\n  } else {\n    unexpected();\n  }\n}\n\nfunction flowParseDeclareModuleExports() {\n  expectContextual(ContextualKeyword._exports);\n  flowParseTypeAnnotation();\n  semicolon();\n}\n\nfunction flowParseDeclareTypeAlias() {\n  next();\n  flowParseTypeAlias();\n}\n\nfunction flowParseDeclareOpaqueType() {\n  next();\n  flowParseOpaqueType(true);\n}\n\nfunction flowParseDeclareInterface() {\n  next();\n  flowParseInterfaceish();\n}\n\n// Interfaces\n\nfunction flowParseInterfaceish(isClass = false) {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (!isClass && eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._mixins)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  if (isContextual(ContextualKeyword._implements)) {\n    next();\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n\n  flowParseObjectType(isClass, false, isClass);\n}\n\nfunction flowParseInterfaceExtends() {\n  flowParseQualifiedTypeIdentifier(false);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseInterface() {\n  flowParseInterfaceish();\n}\n\nfunction flowParseRestrictedIdentifier() {\n  parseIdentifier();\n}\n\nfunction flowParseTypeAlias() {\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  flowParseTypeInitialiser(tt.eq);\n  semicolon();\n}\n\nfunction flowParseOpaqueType(declare) {\n  expectContextual(ContextualKeyword._type);\n  flowParseRestrictedIdentifier();\n\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  // Parse the supertype\n  if (match(tt.colon)) {\n    flowParseTypeInitialiser(tt.colon);\n  }\n\n  if (!declare) {\n    flowParseTypeInitialiser(tt.eq);\n  }\n  semicolon();\n}\n\nfunction flowParseTypeParameter() {\n  flowParseVariance();\n  flowParseTypeAnnotatableIdentifier();\n\n  if (eat(tt.eq)) {\n    flowParseType();\n  }\n}\n\nexport function flowParseTypeParameterDeclaration() {\n  const oldIsType = pushTypeContext(0);\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (match(tt.lessThan) || match(tt.typeParameterStart)) {\n    next();\n  } else {\n    unexpected();\n  }\n\n  do {\n    flowParseTypeParameter();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  } while (!match(tt.greaterThan) && !state.error);\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseTypeParameterInstantiation() {\n  const oldIsType = pushTypeContext(0);\n  expect(tt.lessThan);\n  while (!match(tt.greaterThan) && !state.error) {\n    flowParseType();\n    if (!match(tt.greaterThan)) {\n      expect(tt.comma);\n    }\n  }\n  expect(tt.greaterThan);\n  popTypeContext(oldIsType);\n}\n\nfunction flowParseInterfaceType() {\n  expectContextual(ContextualKeyword._interface);\n  if (eat(tt._extends)) {\n    do {\n      flowParseInterfaceExtends();\n    } while (eat(tt.comma));\n  }\n  flowParseObjectType(false, false, false);\n}\n\nfunction flowParseObjectPropertyKey() {\n  if (match(tt.num) || match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseObjectTypeIndexer() {\n  // Note: bracketL has already been consumed\n  if (lookaheadType() === tt.colon) {\n    flowParseObjectPropertyKey();\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n  expect(tt.bracketR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeInternalSlot() {\n  // Note: both bracketL have already been consumed\n  flowParseObjectPropertyKey();\n  expect(tt.bracketR);\n  expect(tt.bracketR);\n  if (match(tt.lessThan) || match(tt.parenL)) {\n    flowParseObjectTypeMethodish();\n  } else {\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  }\n}\n\nfunction flowParseObjectTypeMethodish() {\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n  }\n\n  expect(tt.parenL);\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n  expect(tt.parenR);\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseObjectTypeCallProperty() {\n  flowParseObjectTypeMethodish();\n}\n\nfunction flowParseObjectType(allowStatic, allowExact, allowProto) {\n  let endDelim;\n  if (allowExact && match(tt.braceBarL)) {\n    expect(tt.braceBarL);\n    endDelim = tt.braceBarR;\n  } else {\n    expect(tt.braceL);\n    endDelim = tt.braceR;\n  }\n\n  while (!match(endDelim) && !state.error) {\n    if (allowProto && isContextual(ContextualKeyword._proto)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n        allowStatic = false;\n      }\n    }\n    if (allowStatic && isContextual(ContextualKeyword._static)) {\n      const lookahead = lookaheadType();\n      if (lookahead !== tt.colon && lookahead !== tt.question) {\n        next();\n      }\n    }\n\n    flowParseVariance();\n\n    if (eat(tt.bracketL)) {\n      if (eat(tt.bracketL)) {\n        flowParseObjectTypeInternalSlot();\n      } else {\n        flowParseObjectTypeIndexer();\n      }\n    } else if (match(tt.parenL) || match(tt.lessThan)) {\n      flowParseObjectTypeCallProperty();\n    } else {\n      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {\n        const lookahead = lookaheadType();\n        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {\n          next();\n        }\n      }\n\n      flowParseObjectTypeProperty();\n    }\n\n    flowObjectTypeSemicolon();\n  }\n\n  expect(endDelim);\n}\n\nfunction flowParseObjectTypeProperty() {\n  if (match(tt.ellipsis)) {\n    expect(tt.ellipsis);\n    if (!eat(tt.comma)) {\n      eat(tt.semi);\n    }\n    // Explicit inexact object syntax.\n    if (match(tt.braceR)) {\n      return;\n    }\n    flowParseType();\n  } else {\n    flowParseObjectPropertyKey();\n    if (match(tt.lessThan) || match(tt.parenL)) {\n      // This is a method property\n      flowParseObjectTypeMethodish();\n    } else {\n      eat(tt.question);\n      flowParseTypeInitialiser();\n    }\n  }\n}\n\nfunction flowObjectTypeSemicolon() {\n  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {\n    unexpected();\n  }\n}\n\nfunction flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {\n  if (!initialIdAlreadyParsed) {\n    parseIdentifier();\n  }\n  while (eat(tt.dot)) {\n    parseIdentifier();\n  }\n}\n\nfunction flowParseGenericType() {\n  flowParseQualifiedTypeIdentifier(true);\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n}\n\nfunction flowParseTypeofType() {\n  expect(tt._typeof);\n  flowParsePrimaryType();\n}\n\nfunction flowParseTupleType() {\n  expect(tt.bracketL);\n  // We allow trailing commas\n  while (state.pos < input.length && !match(tt.bracketR)) {\n    flowParseType();\n    if (match(tt.bracketR)) {\n      break;\n    }\n    expect(tt.comma);\n  }\n  expect(tt.bracketR);\n}\n\nfunction flowParseFunctionTypeParam() {\n  const lookahead = lookaheadType();\n  if (lookahead === tt.colon || lookahead === tt.question) {\n    parseIdentifier();\n    eat(tt.question);\n    flowParseTypeInitialiser();\n  } else {\n    flowParseType();\n  }\n}\n\nfunction flowParseFunctionTypeParams() {\n  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {\n    flowParseFunctionTypeParam();\n    if (!match(tt.parenR)) {\n      expect(tt.comma);\n    }\n  }\n  if (eat(tt.ellipsis)) {\n    flowParseFunctionTypeParam();\n  }\n}\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\nfunction flowParsePrimaryType() {\n  let isGroupedType = false;\n  const oldNoAnonFunctionType = state.noAnonFunctionType;\n\n  switch (state.type) {\n    case tt.name: {\n      if (isContextual(ContextualKeyword._interface)) {\n        flowParseInterfaceType();\n        return;\n      }\n      parseIdentifier();\n      flowParseGenericType();\n      return;\n    }\n\n    case tt.braceL:\n      flowParseObjectType(false, false, false);\n      return;\n\n    case tt.braceBarL:\n      flowParseObjectType(false, true, false);\n      return;\n\n    case tt.bracketL:\n      flowParseTupleType();\n      return;\n\n    case tt.lessThan:\n      flowParseTypeParameterDeclaration();\n      expect(tt.parenL);\n      flowParseFunctionTypeParams();\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.parenL:\n      next();\n\n      // Check to see if this is actually a grouped type\n      if (!match(tt.parenR) && !match(tt.ellipsis)) {\n        if (match(tt.name)) {\n          const token = lookaheadType();\n          isGroupedType = token !== tt.question && token !== tt.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n\n      if (isGroupedType) {\n        state.noAnonFunctionType = false;\n        flowParseType();\n        state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (\n          state.noAnonFunctionType ||\n          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))\n        ) {\n          expect(tt.parenR);\n          return;\n        } else {\n          // Eat a comma if there is one\n          eat(tt.comma);\n        }\n      }\n\n      flowParseFunctionTypeParams();\n\n      expect(tt.parenR);\n      expect(tt.arrow);\n      flowParseType();\n      return;\n\n    case tt.minus:\n      next();\n      parseLiteral();\n      return;\n\n    case tt.string:\n    case tt.num:\n    case tt._true:\n    case tt._false:\n    case tt._null:\n    case tt._this:\n    case tt._void:\n    case tt.star:\n      next();\n      return;\n\n    default:\n      if (state.type === tt._typeof) {\n        flowParseTypeofType();\n        return;\n      } else if (state.type & TokenType.IS_KEYWORD) {\n        next();\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        return;\n      }\n  }\n\n  unexpected();\n}\n\nfunction flowParsePostfixType() {\n  flowParsePrimaryType();\n  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {\n    eat(tt.questionDot);\n    expect(tt.bracketL);\n    if (eat(tt.bracketR)) {\n      // Array type\n    } else {\n      // Indexed access type\n      flowParseType();\n      expect(tt.bracketR);\n    }\n  }\n}\n\nfunction flowParsePrefixType() {\n  if (eat(tt.question)) {\n    flowParsePrefixType();\n  } else {\n    flowParsePostfixType();\n  }\n}\n\nfunction flowParseAnonFunctionWithoutParens() {\n  flowParsePrefixType();\n  if (!state.noAnonFunctionType && eat(tt.arrow)) {\n    flowParseType();\n  }\n}\n\nfunction flowParseIntersectionType() {\n  eat(tt.bitwiseAND);\n  flowParseAnonFunctionWithoutParens();\n  while (eat(tt.bitwiseAND)) {\n    flowParseAnonFunctionWithoutParens();\n  }\n}\n\nfunction flowParseUnionType() {\n  eat(tt.bitwiseOR);\n  flowParseIntersectionType();\n  while (eat(tt.bitwiseOR)) {\n    flowParseIntersectionType();\n  }\n}\n\nfunction flowParseType() {\n  flowParseUnionType();\n}\n\nexport function flowParseTypeAnnotation() {\n  flowParseTypeInitialiser();\n}\n\nfunction flowParseTypeAnnotatableIdentifier() {\n  parseIdentifier();\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\nexport function flowParseVariance() {\n  if (match(tt.plus) || match(tt.minus)) {\n    next();\n    state.tokens[state.tokens.length - 1].isType = true;\n  }\n}\n\n// ==================================\n// Overrides\n// ==================================\n\nexport function flowParseFunctionBodyAndFinish(funcContextId) {\n  // For arrow functions, `parseArrow` handles the return type itself.\n  if (match(tt.colon)) {\n    flowParseTypeAndPredicateInitialiser();\n  }\n\n  parseFunctionBody(false, funcContextId);\n}\n\nexport function flowParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {\n    if (noCalls) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    return;\n  } else if (!noCalls && match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    expect(tt.parenL);\n    parseCallExpressionArguments();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    } else {\n      return;\n    }\n  }\n  baseParseSubscript(startTokenIndex, noCalls, stopState);\n}\n\nexport function flowStartParseNewArguments() {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    flowParseTypeParameterInstantiation();\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n  }\n}\n\n// interfaces\nexport function flowTryParseStatement() {\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._interface) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n    return true;\n  } else if (isContextual(ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n}\n\nexport function flowTryParseExportDefaultExpression() {\n  if (isContextual(ContextualKeyword._enum)) {\n    flowParseEnumDeclaration();\n    return true;\n  }\n  return false;\n}\n\n// declares, interfaces and type aliases\nexport function flowParseIdentifierStatement(contextualKeyword) {\n  if (contextualKeyword === ContextualKeyword._declare) {\n    if (\n      match(tt._class) ||\n      match(tt.name) ||\n      match(tt._function) ||\n      match(tt._var) ||\n      match(tt._export)\n    ) {\n      const oldIsType = pushTypeContext(1);\n      flowParseDeclare();\n      popTypeContext(oldIsType);\n    }\n  } else if (match(tt.name)) {\n    if (contextualKeyword === ContextualKeyword._interface) {\n      const oldIsType = pushTypeContext(1);\n      flowParseInterface();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._type) {\n      const oldIsType = pushTypeContext(1);\n      flowParseTypeAlias();\n      popTypeContext(oldIsType);\n    } else if (contextualKeyword === ContextualKeyword._opaque) {\n      const oldIsType = pushTypeContext(1);\n      flowParseOpaqueType(false);\n      popTypeContext(oldIsType);\n    }\n  }\n  semicolon();\n}\n\n// export type\nexport function flowShouldParseExportDeclaration() {\n  return (\n    isContextual(ContextualKeyword._type) ||\n    isContextual(ContextualKeyword._interface) ||\n    isContextual(ContextualKeyword._opaque) ||\n    isContextual(ContextualKeyword._enum)\n  );\n}\n\nexport function flowShouldDisallowExportDefaultSpecifier() {\n  return (\n    match(tt.name) &&\n    (state.contextualKeyword === ContextualKeyword._type ||\n      state.contextualKeyword === ContextualKeyword._interface ||\n      state.contextualKeyword === ContextualKeyword._opaque ||\n      state.contextualKeyword === ContextualKeyword._enum)\n  );\n}\n\nexport function flowParseExportDeclaration() {\n  if (isContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n\n    if (match(tt.braceL)) {\n      // export type { foo, bar };\n      parseExportSpecifiers();\n      parseExportFrom();\n    } else {\n      // export type Foo = Bar;\n      flowParseTypeAlias();\n    }\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._opaque)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    // export opaque type Foo = Bar;\n    flowParseOpaqueType(false);\n    popTypeContext(oldIsType);\n  } else if (isContextual(ContextualKeyword._interface)) {\n    const oldIsType = pushTypeContext(1);\n    next();\n    flowParseInterface();\n    popTypeContext(oldIsType);\n  } else {\n    parseStatement(true);\n  }\n}\n\nexport function flowShouldParseExportStar() {\n  return match(tt.star) || (isContextual(ContextualKeyword._type) && lookaheadType() === tt.star);\n}\n\nexport function flowParseExportStar() {\n  if (eatContextual(ContextualKeyword._type)) {\n    const oldIsType = pushTypeContext(2);\n    baseParseExportStar();\n    popTypeContext(oldIsType);\n  } else {\n    baseParseExportStar();\n  }\n}\n\n// parse a the super class type parameters and implements\nexport function flowAfterParseClassSuper(hasSuper) {\n  if (hasSuper && match(tt.lessThan)) {\n    flowParseTypeParameterInstantiation();\n  }\n  if (isContextual(ContextualKeyword._implements)) {\n    const oldIsType = pushTypeContext(0);\n    next();\n    state.tokens[state.tokens.length - 1].type = tt._implements;\n    do {\n      flowParseRestrictedIdentifier();\n      if (match(tt.lessThan)) {\n        flowParseTypeParameterInstantiation();\n      }\n    } while (eat(tt.comma));\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse type parameters for object method shorthand\nexport function flowStartParseObjPropValue() {\n  // method shorthand\n  if (match(tt.lessThan)) {\n    flowParseTypeParameterDeclaration();\n    if (!match(tt.parenL)) unexpected();\n  }\n}\n\nexport function flowParseAssignableListItemTypes() {\n  const oldIsType = pushTypeContext(0);\n  eat(tt.question);\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n  popTypeContext(oldIsType);\n}\n\n// parse typeof and type imports\nexport function flowStartParseImportSpecifiers() {\n  if (match(tt._typeof) || isContextual(ContextualKeyword._type)) {\n    const lh = lookaheadTypeAndKeyword();\n    if (isMaybeDefaultImport(lh) || lh.type === tt.braceL || lh.type === tt.star) {\n      next();\n    }\n  }\n}\n\n// parse import-type/typeof shorthand\nexport function flowParseImportSpecifier() {\n  const isTypeKeyword =\n    state.contextualKeyword === ContextualKeyword._type || state.type === tt._typeof;\n  if (isTypeKeyword) {\n    next();\n  } else {\n    parseIdentifier();\n  }\n\n  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n    if (isTypeKeyword && !match(tt.name) && !(state.type & TokenType.IS_KEYWORD)) {\n      // `import {type as ,` or `import {type as }`\n    } else {\n      // `import {type as foo`\n      parseIdentifier();\n    }\n  } else {\n    if (isTypeKeyword && (match(tt.name) || !!(state.type & TokenType.IS_KEYWORD))) {\n      // `import {type foo`\n      parseIdentifier();\n    }\n    if (eatContextual(ContextualKeyword._as)) {\n      parseIdentifier();\n    }\n  }\n}\n\n// parse function type parameters - function foo<T>() {}\nexport function flowStartParseFunctionParams() {\n  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon\n  // anyway, so don't try to propagate that information.\n  if (match(tt.lessThan)) {\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n  }\n}\n\n// parse flow type annotations on variable declarator heads - let foo: string = bar\nexport function flowAfterParseVarHead() {\n  if (match(tt.colon)) {\n    flowParseTypeAnnotation();\n  }\n}\n\n// parse the return type of an async arrow function - let foo = (async (): number => {});\nexport function flowStartParseAsyncArrowFromCallExpression() {\n  if (match(tt.colon)) {\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAnnotation();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n  }\n}\n\n// We need to support type parameter declarations for arrow functions. This\n// is tricky. There are three situations we need to handle\n//\n// 1. This is either JSX or an arrow function. We'll try JSX first. If that\n//    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n//    error.\n// 2. This is an arrow function. We'll parse the type parameter declaration,\n//    parse the rest, make sure the rest is an arrow function, and go from\n//    there\n// 3. This is neither. Just call the super method\nexport function flowParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt.lessThan)) {\n    const snapshot = state.snapshot();\n    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n      state.type = tt.typeParameterStart;\n    } else {\n      return wasArrow;\n    }\n\n    const oldIsType = pushTypeContext(0);\n    flowParseTypeParameterDeclaration();\n    popTypeContext(oldIsType);\n    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);\n    if (wasArrow) {\n      return true;\n    }\n    unexpected();\n  }\n\n  return baseParseMaybeAssign(noIn, isWithinParens);\n}\n\n// handle return types for arrow functions\nexport function flowParseArrow() {\n  if (match(tt.colon)) {\n    const oldIsType = pushTypeContext(0);\n    const snapshot = state.snapshot();\n\n    const oldNoAnonFunctionType = state.noAnonFunctionType;\n    state.noAnonFunctionType = true;\n    flowParseTypeAndPredicateInitialiser();\n    state.noAnonFunctionType = oldNoAnonFunctionType;\n\n    if (canInsertSemicolon()) unexpected();\n    if (!match(tt.arrow)) unexpected();\n\n    if (state.error) {\n      state.restoreFromSnapshot(snapshot);\n    }\n    popTypeContext(oldIsType);\n  }\n  return eat(tt.arrow);\n}\n\nexport function flowParseSubscripts(startTokenIndex, noCalls = false) {\n  if (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    match(tt.lessThan)\n  ) {\n    const snapshot = state.snapshot();\n    const wasArrow = parseAsyncArrowWithTypeParameters();\n    if (wasArrow && !state.error) {\n      return;\n    }\n    state.restoreFromSnapshot(snapshot);\n  }\n\n  baseParseSubscripts(startTokenIndex, noCalls);\n}\n\n// Returns true if there was an arrow function here.\nfunction parseAsyncArrowWithTypeParameters() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseFunctionParams();\n  if (!parseArrow()) {\n    return false;\n  }\n  parseArrowExpression(startTokenIndex);\n  return true;\n}\n\nfunction flowParseEnumDeclaration() {\n  expectContextual(ContextualKeyword._enum);\n  state.tokens[state.tokens.length - 1].type = tt._enum;\n  parseIdentifier();\n  flowParseEnumBody();\n}\n\nfunction flowParseEnumBody() {\n  if (eatContextual(ContextualKeyword._of)) {\n    next();\n  }\n  expect(tt.braceL);\n  flowParseEnumMembers();\n  expect(tt.braceR);\n}\n\nfunction flowParseEnumMembers() {\n  while (!match(tt.braceR) && !state.error) {\n    if (eat(tt.ellipsis)) {\n      break;\n    }\n    flowParseEnumMember();\n    if (!match(tt.braceR)) {\n      expect(tt.comma);\n    }\n  }\n}\n\nfunction flowParseEnumMember() {\n  parseIdentifier();\n  if (eat(tt.eq)) {\n    // Flow enum values are always just one token (a string, number, or boolean literal).\n    next();\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}