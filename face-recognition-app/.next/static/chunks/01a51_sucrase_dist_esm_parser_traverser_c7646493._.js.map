{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/traverser/base.js"],"sourcesContent":["import State from \"../tokenizer/state\";\nimport {charCodes} from \"../util/charcodes\";\n\nexport let isJSXEnabled;\nexport let isTypeScriptEnabled;\nexport let isFlowEnabled;\nexport let state;\nexport let input;\nexport let nextContextId;\n\nexport function getNextContextId() {\n  return nextContextId++;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function augmentError(error) {\n  if (\"pos\" in error) {\n    const loc = locationForIndex(error.pos);\n    error.message += ` (${loc.line}:${loc.column})`;\n    error.loc = loc;\n  }\n  return error;\n}\n\nexport class Loc {\n  \n  \n  constructor(line, column) {\n    this.line = line;\n    this.column = column;\n  }\n}\n\nexport function locationForIndex(pos) {\n  let line = 1;\n  let column = 1;\n  for (let i = 0; i < pos; i++) {\n    if (input.charCodeAt(i) === charCodes.lineFeed) {\n      line++;\n      column = 1;\n    } else {\n      column++;\n    }\n  }\n  return new Loc(line, column);\n}\n\nexport function initParser(\n  inputCode,\n  isJSXEnabledArg,\n  isTypeScriptEnabledArg,\n  isFlowEnabledArg,\n) {\n  input = inputCode;\n  state = new State();\n  nextContextId = 1;\n  isJSXEnabled = isJSXEnabledArg;\n  isTypeScriptEnabled = isTypeScriptEnabledArg;\n  isFlowEnabled = isFlowEnabledArg;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;;AAEO,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AAEJ,SAAS;IACd,OAAO;AACT;AAGO,SAAS,aAAa,KAAK;IAChC,IAAI,SAAS,OAAO;QAClB,MAAM,MAAM,iBAAiB,MAAM,GAAG;QACtC,MAAM,OAAO,IAAI,AAAC,KAAgB,OAAZ,IAAI,IAAI,EAAC,KAAc,OAAX,IAAI,MAAM,EAAC;QAC7C,MAAM,GAAG,GAAG;IACd;IACA,OAAO;AACT;AAEO,MAAM;IAGX,YAAY,IAAI,EAAE,MAAM,CAAE;QACxB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;IAChB;AACF;AAEO,SAAS,iBAAiB,GAAG;IAClC,IAAI,OAAO;IACX,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;QAC5B,IAAI,MAAM,UAAU,CAAC,OAAO,gQAAS,CAAC,QAAQ,EAAE;YAC9C;YACA,SAAS;QACX,OAAO;YACL;QACF;IACF;IACA,OAAO,IAAI,IAAI,MAAM;AACvB;AAEO,SAAS,WACd,SAAS,EACT,eAAe,EACf,sBAAsB,EACtB,gBAAgB;IAEhB,QAAQ;IACR,QAAQ,IAAI,+PAAK;IACjB,gBAAgB;IAChB,eAAe;IACf,sBAAsB;IACtB,gBAAgB;AAClB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/traverser/util.js"],"sourcesContent":["import {eat, finishToken, lookaheadTypeAndKeyword, match, nextTokenStart} from \"../tokenizer/index\";\n\nimport {formatTokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {input, state} from \"./base\";\n\n// ## Parser utilities\n\n// Tests whether parsed token is a contextual keyword.\nexport function isContextual(contextualKeyword) {\n  return state.contextualKeyword === contextualKeyword;\n}\n\nexport function isLookaheadContextual(contextualKeyword) {\n  const l = lookaheadTypeAndKeyword();\n  return l.type === tt.name && l.contextualKeyword === contextualKeyword;\n}\n\n// Consumes contextual keyword if possible.\nexport function eatContextual(contextualKeyword) {\n  return state.contextualKeyword === contextualKeyword && eat(tt.name);\n}\n\n// Asserts that following token is given contextual keyword.\nexport function expectContextual(contextualKeyword) {\n  if (!eatContextual(contextualKeyword)) {\n    unexpected();\n  }\n}\n\n// Test whether a semicolon can be inserted at the current position.\nexport function canInsertSemicolon() {\n  return match(tt.eof) || match(tt.braceR) || hasPrecedingLineBreak();\n}\n\nexport function hasPrecedingLineBreak() {\n  const prevToken = state.tokens[state.tokens.length - 1];\n  const lastTokEnd = prevToken ? prevToken.end : 0;\n  for (let i = lastTokEnd; i < state.start; i++) {\n    const code = input.charCodeAt(i);\n    if (\n      code === charCodes.lineFeed ||\n      code === charCodes.carriageReturn ||\n      code === 0x2028 ||\n      code === 0x2029\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function hasFollowingLineBreak() {\n  const nextStart = nextTokenStart();\n  for (let i = state.end; i < nextStart; i++) {\n    const code = input.charCodeAt(i);\n    if (\n      code === charCodes.lineFeed ||\n      code === charCodes.carriageReturn ||\n      code === 0x2028 ||\n      code === 0x2029\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isLineTerminator() {\n  return eat(tt.semi) || canInsertSemicolon();\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\nexport function semicolon() {\n  if (!isLineTerminator()) {\n    unexpected('Unexpected token, expected \";\"');\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error at given pos.\nexport function expect(type) {\n  const matched = eat(type);\n  if (!matched) {\n    unexpected(`Unexpected token, expected \"${formatTokenType(type)}\"`);\n  }\n}\n\n/**\n * Transition the parser to an error state. All code needs to be written to naturally unwind in this\n * state, which allows us to backtrack without exceptions and without error plumbing everywhere.\n */\nexport function unexpected(message = \"Unexpected token\", pos = state.start) {\n  if (state.error) {\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const err = new SyntaxError(message);\n  err.pos = pos;\n  state.error = err;\n  state.pos = input.length;\n  finishToken(tt.eof);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;;;;;AAKO,SAAS,aAAa,iBAAiB;IAC5C,OAAO,4PAAK,CAAC,iBAAiB,KAAK;AACrC;AAEO,SAAS,sBAAsB,iBAAiB;IACrD,MAAM,IAAI,IAAA,+QAAuB;IACjC,OAAO,EAAE,IAAI,KAAK,iQAAE,CAAC,IAAI,IAAI,EAAE,iBAAiB,KAAK;AACvD;AAGO,SAAS,cAAc,iBAAiB;IAC7C,OAAO,4PAAK,CAAC,iBAAiB,KAAK,qBAAqB,IAAA,2PAAG,EAAC,iQAAE,CAAC,IAAI;AACrE;AAGO,SAAS,iBAAiB,iBAAiB;IAChD,IAAI,CAAC,cAAc,oBAAoB;QACrC;IACF;AACF;AAGO,SAAS;IACd,OAAO,IAAA,6PAAK,EAAC,iQAAE,CAAC,GAAG,KAAK,IAAA,6PAAK,EAAC,iQAAE,CAAC,MAAM,KAAK;AAC9C;AAEO,SAAS;IACd,MAAM,YAAY,4PAAK,CAAC,MAAM,CAAC,4PAAK,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE;IACvD,MAAM,aAAa,YAAY,UAAU,GAAG,GAAG;IAC/C,IAAK,IAAI,IAAI,YAAY,IAAI,4PAAK,CAAC,KAAK,EAAE,IAAK;QAC7C,MAAM,OAAO,4PAAK,CAAC,UAAU,CAAC;QAC9B,IACE,SAAS,gQAAS,CAAC,QAAQ,IAC3B,SAAS,gQAAS,CAAC,cAAc,IACjC,SAAS,UACT,SAAS,QACT;YACA,OAAO;QACT;IACF;IACA,OAAO;AACT;AAEO,SAAS;IACd,MAAM,YAAY,IAAA,sQAAc;IAChC,IAAK,IAAI,IAAI,4PAAK,CAAC,GAAG,EAAE,IAAI,WAAW,IAAK;QAC1C,MAAM,OAAO,4PAAK,CAAC,UAAU,CAAC;QAC9B,IACE,SAAS,gQAAS,CAAC,QAAQ,IAC3B,SAAS,gQAAS,CAAC,cAAc,IACjC,SAAS,UACT,SAAS,QACT;YACA,OAAO;QACT;IACF;IACA,OAAO;AACT;AAEO,SAAS;IACd,OAAO,IAAA,2PAAG,EAAC,iQAAE,CAAC,IAAI,KAAK;AACzB;AAIO,SAAS;IACd,IAAI,CAAC,oBAAoB;QACvB,WAAW;IACb;AACF;AAIO,SAAS,OAAO,IAAI;IACzB,MAAM,UAAU,IAAA,2PAAG,EAAC;IACpB,IAAI,CAAC,SAAS;QACZ,WAAW,AAAC,+BAAoD,OAAtB,IAAA,uQAAe,EAAC,OAAM;IAClE;AACF;AAMO,SAAS;QAAW,UAAA,iEAAU,oBAAoB,MAAA,iEAAM,4PAAK,CAAC,KAAK;IACxE,IAAI,4PAAK,CAAC,KAAK,EAAE;QACf;IACF;IACA,8DAA8D;IAC9D,MAAM,MAAM,IAAI,YAAY;IAC5B,IAAI,GAAG,GAAG;IACV,4PAAK,CAAC,KAAK,GAAG;IACd,4PAAK,CAAC,GAAG,GAAG,4PAAK,CAAC,MAAM;IACxB,IAAA,mQAAW,EAAC,iQAAE,CAAC,GAAG;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/traverser/lval.js"],"sourcesContent":["import {flowParseAssignableListItemTypes} from \"../plugins/flow\";\nimport {tsParseAssignableListItemTypes, tsParseModifiers} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  match,\n  next,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {parseIdentifier, parseMaybeAssign, parseObj} from \"./expression\";\nimport {expect, unexpected} from \"./util\";\n\nexport function parseSpread() {\n  next();\n  parseMaybeAssign(false);\n}\n\nexport function parseRest(isBlockScope) {\n  next();\n  parseBindingAtom(isBlockScope);\n}\n\nexport function parseBindingIdentifier(isBlockScope) {\n  parseIdentifier();\n  markPriorBindingIdentifier(isBlockScope);\n}\n\nexport function parseImportedIdentifier() {\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportDeclaration;\n}\n\nexport function markPriorBindingIdentifier(isBlockScope) {\n  let identifierRole;\n  if (state.scopeDepth === 0) {\n    identifierRole = IdentifierRole.TopLevelDeclaration;\n  } else if (isBlockScope) {\n    identifierRole = IdentifierRole.BlockScopedDeclaration;\n  } else {\n    identifierRole = IdentifierRole.FunctionScopedDeclaration;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n}\n\n// Parses lvalue (assignable) atom.\nexport function parseBindingAtom(isBlockScope) {\n  switch (state.type) {\n    case tt._this: {\n      // In TypeScript, \"this\" may be the name of a parameter, so allow it.\n      const oldIsType = pushTypeContext(0);\n      next();\n      popTypeContext(oldIsType);\n      return;\n    }\n\n    case tt._yield:\n    case tt.name: {\n      state.type = tt.name;\n      parseBindingIdentifier(isBlockScope);\n      return;\n    }\n\n    case tt.bracketL: {\n      next();\n      parseBindingList(tt.bracketR, isBlockScope, true /* allowEmpty */);\n      return;\n    }\n\n    case tt.braceL:\n      parseObj(true, isBlockScope);\n      return;\n\n    default:\n      unexpected();\n  }\n}\n\nexport function parseBindingList(\n  close,\n  isBlockScope,\n  allowEmpty = false,\n  allowModifiers = false,\n  contextId = 0,\n) {\n  let first = true;\n\n  let hasRemovedComma = false;\n  const firstItemTokenIndex = state.tokens.length;\n\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      state.tokens[state.tokens.length - 1].contextId = contextId;\n      // After a \"this\" type in TypeScript, we need to set the following comma (if any) to also be\n      // a type token so that it will be removed.\n      if (!hasRemovedComma && state.tokens[firstItemTokenIndex].isType) {\n        state.tokens[state.tokens.length - 1].isType = true;\n        hasRemovedComma = true;\n      }\n    }\n    if (allowEmpty && match(tt.comma)) {\n      // Empty item; nothing further to parse for this item.\n    } else if (eat(close)) {\n      break;\n    } else if (match(tt.ellipsis)) {\n      parseRest(isBlockScope);\n      parseAssignableListItemTypes();\n      // Support rest element trailing commas allowed by TypeScript <2.9.\n      eat(TokenType.comma);\n      expect(close);\n      break;\n    } else {\n      parseAssignableListItem(allowModifiers, isBlockScope);\n    }\n  }\n}\n\nfunction parseAssignableListItem(allowModifiers, isBlockScope) {\n  if (allowModifiers) {\n    tsParseModifiers([\n      ContextualKeyword._public,\n      ContextualKeyword._protected,\n      ContextualKeyword._private,\n      ContextualKeyword._readonly,\n      ContextualKeyword._override,\n    ]);\n  }\n\n  parseMaybeDefault(isBlockScope);\n  parseAssignableListItemTypes();\n  parseMaybeDefault(isBlockScope, true /* leftAlreadyParsed */);\n}\n\nfunction parseAssignableListItemTypes() {\n  if (isFlowEnabled) {\n    flowParseAssignableListItemTypes();\n  } else if (isTypeScriptEnabled) {\n    tsParseAssignableListItemTypes();\n  }\n}\n\n// Parses assignment pattern around given atom if possible.\nexport function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {\n  if (!leftAlreadyParsed) {\n    parseBindingAtom(isBlockScope);\n  }\n  if (!eat(tt.eq)) {\n    return;\n  }\n  const eqIndex = state.tokens.length - 1;\n  parseMaybeAssign();\n  state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/traverser/expression.js"],"sourcesContent":["/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  flowParseArrow,\n  flowParseFunctionBodyAndFinish,\n  flowParseMaybeAssign,\n  flowParseSubscript,\n  flowParseSubscripts,\n  flowParseVariance,\n  flowStartParseAsyncArrowFromCallExpression,\n  flowStartParseNewArguments,\n  flowStartParseObjPropValue,\n} from \"../plugins/flow\";\nimport {jsxParseElement} from \"../plugins/jsx/index\";\nimport {typedParseConditional, typedParseParenItem} from \"../plugins/types\";\nimport {\n  tsParseArrow,\n  tsParseFunctionBodyAndFinish,\n  tsParseMaybeAssign,\n  tsParseSubscript,\n  tsParseType,\n  tsParseTypeAssertion,\n  tsStartParseAsyncArrowFromCallExpression,\n  tsStartParseObjPropValue,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  IdentifierRole,\n  lookaheadCharCode,\n  lookaheadType,\n  match,\n  next,\n  nextTemplateToken,\n  popTypeContext,\n  pushTypeContext,\n  rescan_gt,\n  retokenizeSlashAsRegex,\n} from \"../tokenizer/index\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport {TokenType, TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {IS_IDENTIFIER_START} from \"../util/identifier\";\nimport {getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  markPriorBindingIdentifier,\n  parseBindingIdentifier,\n  parseMaybeDefault,\n  parseRest,\n  parseSpread,\n} from \"./lval\";\nimport {\n  parseBlock,\n  parseBlockBody,\n  parseClass,\n  parseDecorators,\n  parseFunction,\n  parseFunctionParams,\n} from \"./statement\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasFollowingLineBreak,\n  hasPrecedingLineBreak,\n  isContextual,\n  unexpected,\n} from \"./util\";\n\nexport class StopState {\n  \n  constructor(stop) {\n    this.stop = stop;\n  }\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\nexport function parseExpression(noIn = false) {\n  parseMaybeAssign(noIn);\n  if (match(tt.comma)) {\n    while (eat(tt.comma)) {\n      parseMaybeAssign(noIn);\n    }\n  }\n}\n\n/**\n * noIn is used when parsing a for loop so that we don't interpret a following \"in\" as the binary\n * operatior.\n * isWithinParens is used to indicate that we're parsing something that might be a comma expression\n * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).\n * In these cases, we should allow : and ?: after the initial \"left\" part.\n */\nexport function parseMaybeAssign(noIn = false, isWithinParens = false) {\n  if (isTypeScriptEnabled) {\n    return tsParseMaybeAssign(noIn, isWithinParens);\n  } else if (isFlowEnabled) {\n    return flowParseMaybeAssign(noIn, isWithinParens);\n  } else {\n    return baseParseMaybeAssign(noIn, isWithinParens);\n  }\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n// Returns true if the expression was an arrow function.\nexport function baseParseMaybeAssign(noIn, isWithinParens) {\n  if (match(tt._yield)) {\n    parseYield();\n    return false;\n  }\n\n  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {\n    state.potentialArrowAt = state.start;\n  }\n\n  const wasArrow = parseMaybeConditional(noIn);\n  if (isWithinParens) {\n    parseParenItem();\n  }\n  if (state.type & TokenType.IS_ASSIGN) {\n    next();\n    parseMaybeAssign(noIn);\n    return false;\n  }\n  return wasArrow;\n}\n\n// Parse a ternary conditional (`?:`) operator.\n// Returns true if the expression was an arrow function.\nfunction parseMaybeConditional(noIn) {\n  const wasArrow = parseExprOps(noIn);\n  if (wasArrow) {\n    return true;\n  }\n  parseConditional(noIn);\n  return false;\n}\n\nfunction parseConditional(noIn) {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseConditional(noIn);\n  } else {\n    baseParseConditional(noIn);\n  }\n}\n\nexport function baseParseConditional(noIn) {\n  if (eat(tt.question)) {\n    parseMaybeAssign();\n    expect(tt.colon);\n    parseMaybeAssign(noIn);\n  }\n}\n\n// Start the precedence parser.\n// Returns true if this was an arrow function\nfunction parseExprOps(noIn) {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseMaybeUnary();\n  if (wasArrow) {\n    return true;\n  }\n  parseExprOp(startTokenIndex, -1, noIn);\n  return false;\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\nfunction parseExprOp(startTokenIndex, minPrec, noIn) {\n  if (\n    isTypeScriptEnabled &&\n    (tt._in & TokenType.PRECEDENCE_MASK) > minPrec &&\n    !hasPrecedingLineBreak() &&\n    (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))\n  ) {\n    const oldIsType = pushTypeContext(1);\n    tsParseType();\n    popTypeContext(oldIsType);\n    rescan_gt();\n    parseExprOp(startTokenIndex, minPrec, noIn);\n    return;\n  }\n\n  const prec = state.type & TokenType.PRECEDENCE_MASK;\n  if (prec > 0 && (!noIn || !match(tt._in))) {\n    if (prec > minPrec) {\n      const op = state.type;\n      next();\n      if (op === tt.nullishCoalescing) {\n        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;\n      }\n\n      const rhsStartTokenIndex = state.tokens.length;\n      parseMaybeUnary();\n      // Extend the right operand of this operator if possible.\n      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);\n      if (op === tt.nullishCoalescing) {\n        state.tokens[startTokenIndex].numNullishCoalesceStarts++;\n        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;\n      }\n      // Continue with any future operator holding this expression as the left operand.\n      parseExprOp(startTokenIndex, minPrec, noIn);\n    }\n  }\n}\n\n// Parse unary operators, both prefix and postfix.\n// Returns true if this was an arrow function.\nexport function parseMaybeUnary() {\n  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {\n    tsParseTypeAssertion();\n    return false;\n  }\n  if (\n    isContextual(ContextualKeyword._module) &&\n    lookaheadCharCode() === charCodes.leftCurlyBrace &&\n    !hasFollowingLineBreak()\n  ) {\n    parseModuleExpression();\n    return false;\n  }\n  if (state.type & TokenType.IS_PREFIX) {\n    next();\n    parseMaybeUnary();\n    return false;\n  }\n\n  const wasArrow = parseExprSubscripts();\n  if (wasArrow) {\n    return true;\n  }\n  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {\n    // The tokenizer calls everything a preincrement, so make it a postincrement when\n    // we see it in that context.\n    if (state.type === tt.preIncDec) {\n      state.type = tt.postIncDec;\n    }\n    next();\n  }\n  return false;\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n// Returns true if this was an arrow function.\nexport function parseExprSubscripts() {\n  const startTokenIndex = state.tokens.length;\n  const wasArrow = parseExprAtom();\n  if (wasArrow) {\n    return true;\n  }\n  parseSubscripts(startTokenIndex);\n  // If there was any optional chain operation, the start token would be marked\n  // as such, so also mark the end now.\n  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {\n    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;\n  }\n  return false;\n}\n\nfunction parseSubscripts(startTokenIndex, noCalls = false) {\n  if (isFlowEnabled) {\n    flowParseSubscripts(startTokenIndex, noCalls);\n  } else {\n    baseParseSubscripts(startTokenIndex, noCalls);\n  }\n}\n\nexport function baseParseSubscripts(startTokenIndex, noCalls = false) {\n  const stopState = new StopState(false);\n  do {\n    parseSubscript(startTokenIndex, noCalls, stopState);\n  } while (!stopState.stop && !state.error);\n}\n\nfunction parseSubscript(startTokenIndex, noCalls, stopState) {\n  if (isTypeScriptEnabled) {\n    tsParseSubscript(startTokenIndex, noCalls, stopState);\n  } else if (isFlowEnabled) {\n    flowParseSubscript(startTokenIndex, noCalls, stopState);\n  } else {\n    baseParseSubscript(startTokenIndex, noCalls, stopState);\n  }\n}\n\n/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\nexport function baseParseSubscript(\n  startTokenIndex,\n  noCalls,\n  stopState,\n) {\n  if (!noCalls && eat(tt.doubleColon)) {\n    parseNoCallExpr();\n    stopState.stop = true;\n    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want\n    // to revisit this in the future when fully supporting bind syntax.\n    parseSubscripts(startTokenIndex, noCalls);\n  } else if (match(tt.questionDot)) {\n    state.tokens[startTokenIndex].isOptionalChainStart = true;\n    if (noCalls && lookaheadType() === tt.parenL) {\n      stopState.stop = true;\n      return;\n    }\n    next();\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n    if (eat(tt.bracketL)) {\n      parseExpression();\n      expect(tt.bracketR);\n    } else if (eat(tt.parenL)) {\n      parseCallExpressionArguments();\n    } else {\n      parseMaybePrivateName();\n    }\n  } else if (eat(tt.dot)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseMaybePrivateName();\n  } else if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n    parseExpression();\n    expect(tt.bracketR);\n  } else if (!noCalls && match(tt.parenL)) {\n    if (atPossibleAsync()) {\n      // We see \"async\", but it's possible it's a usage of the name \"async\". Parse as if it's a\n      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.\n      const snapshot = state.snapshot();\n      const asyncStartTokenIndex = state.tokens.length;\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n\n      const callContextId = getNextContextId();\n\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n\n      if (shouldParseAsyncArrow()) {\n        // We hit an arrow, so backtrack and start again parsing function parameters.\n        state.restoreFromSnapshot(snapshot);\n        stopState.stop = true;\n        state.scopeDepth++;\n\n        parseFunctionParams();\n        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);\n      }\n    } else {\n      next();\n      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;\n      const callContextId = getNextContextId();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n      parseCallExpressionArguments();\n      state.tokens[state.tokens.length - 1].contextId = callContextId;\n    }\n  } else if (match(tt.backQuote)) {\n    // Tagged template expression.\n    parseTemplate();\n  } else {\n    stopState.stop = true;\n  }\n}\n\nexport function atPossibleAsync() {\n  // This was made less strict than the original version to avoid passing around nodes, but it\n  // should be safe to have rare false positives here.\n  return (\n    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&\n    !canInsertSemicolon()\n  );\n}\n\nexport function parseCallExpressionArguments() {\n  let first = true;\n  while (!eat(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.parenR)) {\n        break;\n      }\n    }\n\n    parseExprListItem(false);\n  }\n}\n\nfunction shouldParseAsyncArrow() {\n  return match(tt.colon) || match(tt.arrow);\n}\n\nfunction parseAsyncArrowFromCallExpression(startTokenIndex) {\n  if (isTypeScriptEnabled) {\n    tsStartParseAsyncArrowFromCallExpression();\n  } else if (isFlowEnabled) {\n    flowStartParseAsyncArrowFromCallExpression();\n  }\n  expect(tt.arrow);\n  parseArrowExpression(startTokenIndex);\n}\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\nfunction parseNoCallExpr() {\n  const startTokenIndex = state.tokens.length;\n  parseExprAtom();\n  parseSubscripts(startTokenIndex, true);\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n// Returns true if the parsed expression was an arrow function.\nexport function parseExprAtom() {\n  if (eat(tt.modulo)) {\n    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed\n    // naturally.\n    parseIdentifier();\n    return false;\n  }\n\n  if (match(tt.jsxText) || match(tt.jsxEmptyText)) {\n    parseLiteral();\n    return false;\n  } else if (match(tt.lessThan) && isJSXEnabled) {\n    state.type = tt.jsxTagStart;\n    jsxParseElement();\n    next();\n    return false;\n  }\n\n  const canBeArrow = state.potentialArrowAt === state.start;\n  switch (state.type) {\n    case tt.slash:\n    case tt.assign:\n      retokenizeSlashAsRegex();\n    // Fall through.\n\n    case tt._super:\n    case tt._this:\n    case tt.regexp:\n    case tt.num:\n    case tt.bigint:\n    case tt.decimal:\n    case tt.string:\n    case tt._null:\n    case tt._true:\n    case tt._false:\n      next();\n      return false;\n\n    case tt._import:\n      next();\n      if (match(tt.dot)) {\n        // import.meta\n        state.tokens[state.tokens.length - 1].type = tt.name;\n        next();\n        parseIdentifier();\n      }\n      return false;\n\n    case tt.name: {\n      const startTokenIndex = state.tokens.length;\n      const functionStart = state.start;\n      const contextualKeyword = state.contextualKeyword;\n      parseIdentifier();\n      if (contextualKeyword === ContextualKeyword._await) {\n        parseAwait();\n        return false;\n      } else if (\n        contextualKeyword === ContextualKeyword._async &&\n        match(tt._function) &&\n        !canInsertSemicolon()\n      ) {\n        next();\n        parseFunction(functionStart, false);\n        return false;\n      } else if (\n        canBeArrow &&\n        contextualKeyword === ContextualKeyword._async &&\n        !canInsertSemicolon() &&\n        match(tt.name)\n      ) {\n        state.scopeDepth++;\n        parseBindingIdentifier(false);\n        expect(tt.arrow);\n        // let foo = async bar => {};\n        parseArrowExpression(startTokenIndex);\n        return true;\n      } else if (match(tt._do) && !canInsertSemicolon()) {\n        next();\n        parseBlock();\n        return false;\n      }\n\n      if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {\n        state.scopeDepth++;\n        markPriorBindingIdentifier(false);\n        expect(tt.arrow);\n        parseArrowExpression(startTokenIndex);\n        return true;\n      }\n\n      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;\n      return false;\n    }\n\n    case tt._do: {\n      next();\n      parseBlock();\n      return false;\n    }\n\n    case tt.parenL: {\n      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);\n      return wasArrow;\n    }\n\n    case tt.bracketL:\n      next();\n      parseExprList(tt.bracketR, true);\n      return false;\n\n    case tt.braceL:\n      parseObj(false, false);\n      return false;\n\n    case tt._function:\n      parseFunctionExpression();\n      return false;\n\n    case tt.at:\n      parseDecorators();\n    // Fall through.\n\n    case tt._class:\n      parseClass(false);\n      return false;\n\n    case tt._new:\n      parseNew();\n      return false;\n\n    case tt.backQuote:\n      parseTemplate();\n      return false;\n\n    case tt.doubleColon: {\n      next();\n      parseNoCallExpr();\n      return false;\n    }\n\n    case tt.hash: {\n      const code = lookaheadCharCode();\n      if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {\n        parseMaybePrivateName();\n      } else {\n        next();\n      }\n      // Smart pipeline topic reference.\n      return false;\n    }\n\n    default:\n      unexpected();\n      return false;\n  }\n}\n\nfunction parseMaybePrivateName() {\n  eat(tt.hash);\n  parseIdentifier();\n}\n\nfunction parseFunctionExpression() {\n  const functionStart = state.start;\n  parseIdentifier();\n  if (eat(tt.dot)) {\n    // function.sent\n    parseIdentifier();\n  }\n  parseFunction(functionStart, false);\n}\n\nexport function parseLiteral() {\n  next();\n}\n\nexport function parseParenExpression() {\n  expect(tt.parenL);\n  parseExpression();\n  expect(tt.parenR);\n}\n\n// Returns true if this was an arrow expression.\nfunction parseParenAndDistinguishExpression(canBeArrow) {\n  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and\n  // start over as a parameter list.\n  const snapshot = state.snapshot();\n\n  const startTokenIndex = state.tokens.length;\n  expect(tt.parenL);\n\n  let first = true;\n\n  while (!match(tt.parenR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (match(tt.parenR)) {\n        break;\n      }\n    }\n\n    if (match(tt.ellipsis)) {\n      parseRest(false /* isBlockScope */);\n      parseParenItem();\n      break;\n    } else {\n      parseMaybeAssign(false, true);\n    }\n  }\n\n  expect(tt.parenR);\n\n  if (canBeArrow && shouldParseArrow()) {\n    const wasArrow = parseArrow();\n    if (wasArrow) {\n      // It was an arrow function this whole time, so start over and parse it as params so that we\n      // get proper token annotations.\n      state.restoreFromSnapshot(snapshot);\n      state.scopeDepth++;\n      // Don't specify a context ID because arrow functions don't need a context ID.\n      parseFunctionParams();\n      parseArrow();\n      parseArrowExpression(startTokenIndex);\n      if (state.error) {\n        // Nevermind! This must have been something that looks very much like an\n        // arrow function but where its \"parameter list\" isn't actually a valid\n        // parameter list. Force non-arrow parsing.\n        // See https://github.com/alangpierce/sucrase/issues/666 for an example.\n        state.restoreFromSnapshot(snapshot);\n        parseParenAndDistinguishExpression(false);\n        return false;\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldParseArrow() {\n  return match(tt.colon) || !canInsertSemicolon();\n}\n\n// Returns whether there was an arrow token.\nexport function parseArrow() {\n  if (isTypeScriptEnabled) {\n    return tsParseArrow();\n  } else if (isFlowEnabled) {\n    return flowParseArrow();\n  } else {\n    return eat(tt.arrow);\n  }\n}\n\nfunction parseParenItem() {\n  if (isTypeScriptEnabled || isFlowEnabled) {\n    typedParseParenItem();\n  }\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nfunction parseNew() {\n  expect(tt._new);\n  if (eat(tt.dot)) {\n    // new.target\n    parseIdentifier();\n    return;\n  }\n  parseNewCallee();\n  if (isFlowEnabled) {\n    flowStartParseNewArguments();\n  }\n  if (eat(tt.parenL)) {\n    parseExprList(tt.parenR);\n  }\n}\n\nfunction parseNewCallee() {\n  parseNoCallExpr();\n  eat(tt.questionDot);\n}\n\nexport function parseTemplate() {\n  // Finish `, read quasi\n  nextTemplateToken();\n  // Finish quasi, read ${\n  nextTemplateToken();\n  while (!match(tt.backQuote) && !state.error) {\n    expect(tt.dollarBraceL);\n    parseExpression();\n    // Finish }, read quasi\n    nextTemplateToken();\n    // Finish quasi, read either ${ or `\n    nextTemplateToken();\n  }\n  next();\n}\n\n// Parse an object literal or binding pattern.\nexport function parseObj(isPattern, isBlockScope) {\n  // Attach a context ID to the object open and close brace and each object key.\n  const contextId = getNextContextId();\n  let first = true;\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    let isGenerator = false;\n    if (match(tt.ellipsis)) {\n      const previousIndex = state.tokens.length;\n      parseSpread();\n      if (isPattern) {\n        // Mark role when the only thing being spread over is an identifier.\n        if (state.tokens.length === previousIndex + 2) {\n          markPriorBindingIdentifier(isBlockScope);\n        }\n        if (eat(tt.braceR)) {\n          break;\n        }\n      }\n      continue;\n    }\n\n    if (!isPattern) {\n      isGenerator = eat(tt.star);\n    }\n\n    if (!isPattern && isContextual(ContextualKeyword._async)) {\n      if (isGenerator) unexpected();\n\n      parseIdentifier();\n      if (\n        match(tt.colon) ||\n        match(tt.parenL) ||\n        match(tt.braceR) ||\n        match(tt.eq) ||\n        match(tt.comma)\n      ) {\n        // This is a key called \"async\" rather than an async function.\n      } else {\n        if (match(tt.star)) {\n          next();\n          isGenerator = true;\n        }\n        parsePropertyName(contextId);\n      }\n    } else {\n      parsePropertyName(contextId);\n    }\n\n    parseObjPropValue(isPattern, isBlockScope, contextId);\n  }\n\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n}\n\nfunction isGetterOrSetterMethod(isPattern) {\n  // We go off of the next and don't bother checking if the node key is actually \"get\" or \"set\".\n  // This lets us avoid generating a node, and should only make the validation worse.\n  return (\n    !isPattern &&\n    (match(tt.string) || // get \"string\"() {}\n      match(tt.num) || // get 1() {}\n      match(tt.bracketL) || // get [\"string\"]() {}\n      match(tt.name) || // get foo() {}\n      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}\n  );\n}\n\n// Returns true if this was a method.\nfunction parseObjectMethod(isPattern, objectContextId) {\n  // We don't need to worry about modifiers because object methods can't have optional bodies, so\n  // the start will never be used.\n  const functionStart = state.start;\n  if (match(tt.parenL)) {\n    if (isPattern) unexpected();\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n\n  if (isGetterOrSetterMethod(isPattern)) {\n    parsePropertyName(objectContextId);\n    parseMethod(functionStart, /* isConstructor */ false);\n    return true;\n  }\n  return false;\n}\n\nfunction parseObjectProperty(isPattern, isBlockScope) {\n  if (eat(tt.colon)) {\n    if (isPattern) {\n      parseMaybeDefault(isBlockScope);\n    } else {\n      parseMaybeAssign(false);\n    }\n    return;\n  }\n\n  // Since there's no colon, we assume this is an object shorthand.\n\n  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so\n  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to\n  // transform it on access, so mark it as a normal object shorthand.\n  let identifierRole;\n  if (isPattern) {\n    if (state.scopeDepth === 0) {\n      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;\n    } else if (isBlockScope) {\n      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;\n    } else {\n      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;\n    }\n  } else {\n    identifierRole = IdentifierRole.ObjectShorthand;\n  }\n  state.tokens[state.tokens.length - 1].identifierRole = identifierRole;\n\n  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow\n  // parsing as if there's a default value.\n  parseMaybeDefault(isBlockScope, true);\n}\n\nfunction parseObjPropValue(\n  isPattern,\n  isBlockScope,\n  objectContextId,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseObjPropValue();\n  } else if (isFlowEnabled) {\n    flowStartParseObjPropValue();\n  }\n  const wasMethod = parseObjectMethod(isPattern, objectContextId);\n  if (!wasMethod) {\n    parseObjectProperty(isPattern, isBlockScope);\n  }\n}\n\nexport function parsePropertyName(objectContextId) {\n  if (isFlowEnabled) {\n    flowParseVariance();\n  }\n  if (eat(tt.bracketL)) {\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n    parseMaybeAssign();\n    expect(tt.bracketR);\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  } else {\n    if (match(tt.num) || match(tt.string) || match(tt.bigint) || match(tt.decimal)) {\n      parseExprAtom();\n    } else {\n      parseMaybePrivateName();\n    }\n\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ObjectKey;\n    state.tokens[state.tokens.length - 1].contextId = objectContextId;\n  }\n}\n\n// Parse object or class method.\nexport function parseMethod(functionStart, isConstructor) {\n  const funcContextId = getNextContextId();\n\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  const allowModifiers = isConstructor; // For TypeScript parameter properties\n  parseFunctionParams(allowModifiers, funcContextId);\n  parseFunctionBodyAndFinish(functionStart, funcContextId);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\n// Parse arrow function expression.\n// If the parameters are provided, they will be converted to an\n// assignable list.\nexport function parseArrowExpression(startTokenIndex) {\n  parseFunctionBody(true);\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n}\n\nexport function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {\n  if (isTypeScriptEnabled) {\n    tsParseFunctionBodyAndFinish(functionStart, funcContextId);\n  } else if (isFlowEnabled) {\n    flowParseFunctionBodyAndFinish(funcContextId);\n  } else {\n    parseFunctionBody(false, funcContextId);\n  }\n}\n\nexport function parseFunctionBody(allowExpression, funcContextId = 0) {\n  const isExpression = allowExpression && !match(tt.braceL);\n\n  if (isExpression) {\n    parseMaybeAssign();\n  } else {\n    parseBlock(true /* isFunctionScope */, funcContextId);\n  }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\nfunction parseExprList(close, allowEmpty = false) {\n  let first = true;\n  while (!eat(close) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(close)) break;\n    }\n    parseExprListItem(allowEmpty);\n  }\n}\n\nfunction parseExprListItem(allowEmpty) {\n  if (allowEmpty && match(tt.comma)) {\n    // Empty item; nothing more to parse for this item.\n  } else if (match(tt.ellipsis)) {\n    parseSpread();\n    parseParenItem();\n  } else if (match(tt.question)) {\n    // Partial function application proposal.\n    next();\n  } else {\n    parseMaybeAssign(false, true);\n  }\n}\n\n// Parse the next token as an identifier.\nexport function parseIdentifier() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt.name;\n}\n\n// Parses await expression inside async function.\nfunction parseAwait() {\n  parseMaybeUnary();\n}\n\n// Parses yield expression inside generator.\nfunction parseYield() {\n  next();\n  if (!match(tt.semi) && !canInsertSemicolon()) {\n    eat(tt.star);\n    parseMaybeAssign();\n  }\n}\n\n// https://github.com/tc39/proposal-js-module-blocks\nfunction parseModuleExpression() {\n  expectContextual(ContextualKeyword._module);\n  expect(tt.braceL);\n  // For now, just call parseBlockBody to parse the block. In the future when we\n  // implement full support, we'll want to emit scopes and possibly other\n  // information.\n  parseBlockBody(tt.braceR);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1213, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/traverser/statement.js"],"sourcesContent":["/* eslint max-len: 0 */\n\nimport {File} from \"../index\";\nimport {\n  flowAfterParseClassSuper,\n  flowAfterParseVarHead,\n  flowParseExportDeclaration,\n  flowParseExportStar,\n  flowParseIdentifierStatement,\n  flowParseImportSpecifier,\n  flowParseTypeAnnotation,\n  flowParseTypeParameterDeclaration,\n  flowShouldDisallowExportDefaultSpecifier,\n  flowShouldParseExportDeclaration,\n  flowShouldParseExportStar,\n  flowStartParseFunctionParams,\n  flowStartParseImportSpecifiers,\n  flowTryParseExportDefaultExpression,\n  flowTryParseStatement,\n} from \"../plugins/flow\";\nimport {\n  tsAfterParseClassSuper,\n  tsAfterParseVarHead,\n  tsIsDeclarationStart,\n  tsParseExportDeclaration,\n  tsParseExportSpecifier,\n  tsParseIdentifierStatement,\n  tsParseImportEqualsDeclaration,\n  tsParseImportSpecifier,\n  tsParseMaybeDecoratorArguments,\n  tsParseModifiers,\n  tsStartParseFunctionParams,\n  tsTryParseClassMemberWithIsStatic,\n  tsTryParseExport,\n  tsTryParseExportDefaultExpression,\n  tsTryParseStatementContent,\n  tsTryParseTypeAnnotation,\n  tsTryParseTypeParameters,\n} from \"../plugins/typescript\";\nimport {\n  eat,\n  eatTypeToken,\n  IdentifierRole,\n  lookaheadType,\n  lookaheadTypeAndKeyword,\n  match,\n  next,\n  nextTokenStart,\n  nextTokenStartSince,\n  popTypeContext,\n  pushTypeContext,\n} from \"../tokenizer\";\nimport {ContextualKeyword} from \"../tokenizer/keywords\";\nimport {Scope} from \"../tokenizer/state\";\nimport { TokenType as tt} from \"../tokenizer/types\";\nimport {charCodes} from \"../util/charcodes\";\nimport {getNextContextId, input, isFlowEnabled, isTypeScriptEnabled, state} from \"./base\";\nimport {\n  parseCallExpressionArguments,\n  parseExprAtom,\n  parseExpression,\n  parseExprSubscripts,\n  parseFunctionBodyAndFinish,\n  parseIdentifier,\n  parseMaybeAssign,\n  parseMethod,\n  parseObj,\n  parseParenExpression,\n  parsePropertyName,\n} from \"./expression\";\nimport {\n  parseBindingAtom,\n  parseBindingIdentifier,\n  parseBindingList,\n  parseImportedIdentifier,\n} from \"./lval\";\nimport {\n  canInsertSemicolon,\n  eatContextual,\n  expect,\n  expectContextual,\n  hasFollowingLineBreak,\n  hasPrecedingLineBreak,\n  isContextual,\n  isLineTerminator,\n  isLookaheadContextual,\n  semicolon,\n  unexpected,\n} from \"./util\";\n\nexport function parseTopLevel() {\n  parseBlockBody(tt.eof);\n  state.scopes.push(new Scope(0, state.tokens.length, true));\n  if (state.scopeDepth !== 0) {\n    throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);\n  }\n  return new File(state.tokens, state.scopes);\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\nexport function parseStatement(declaration) {\n  if (isFlowEnabled) {\n    if (flowTryParseStatement()) {\n      return;\n    }\n  }\n  if (match(tt.at)) {\n    parseDecorators();\n  }\n  parseStatementContent(declaration);\n}\n\nfunction parseStatementContent(declaration) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseStatementContent()) {\n      return;\n    }\n  }\n\n  const starttype = state.type;\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case tt._break:\n    case tt._continue:\n      parseBreakContinueStatement();\n      return;\n    case tt._debugger:\n      parseDebuggerStatement();\n      return;\n    case tt._do:\n      parseDoStatement();\n      return;\n    case tt._for:\n      parseForStatement();\n      return;\n    case tt._function:\n      if (lookaheadType() === tt.dot) break;\n      if (!declaration) unexpected();\n      parseFunctionStatement();\n      return;\n\n    case tt._class:\n      if (!declaration) unexpected();\n      parseClass(true);\n      return;\n\n    case tt._if:\n      parseIfStatement();\n      return;\n    case tt._return:\n      parseReturnStatement();\n      return;\n    case tt._switch:\n      parseSwitchStatement();\n      return;\n    case tt._throw:\n      parseThrowStatement();\n      return;\n    case tt._try:\n      parseTryStatement();\n      return;\n\n    case tt._let:\n    case tt._const:\n      if (!declaration) unexpected(); // NOTE: falls through to _var\n\n    case tt._var:\n      parseVarStatement(starttype !== tt._var);\n      return;\n\n    case tt._while:\n      parseWhileStatement();\n      return;\n    case tt.braceL:\n      parseBlock();\n      return;\n    case tt.semi:\n      parseEmptyStatement();\n      return;\n    case tt._export:\n    case tt._import: {\n      const nextType = lookaheadType();\n      if (nextType === tt.parenL || nextType === tt.dot) {\n        break;\n      }\n      next();\n      if (starttype === tt._import) {\n        parseImport();\n      } else {\n        parseExport();\n      }\n      return;\n    }\n    case tt.name:\n      if (state.contextualKeyword === ContextualKeyword._async) {\n        const functionStart = state.start;\n        // peek ahead and see if next token is a function\n        const snapshot = state.snapshot();\n        next();\n        if (match(tt._function) && !canInsertSemicolon()) {\n          expect(tt._function);\n          parseFunction(functionStart, true);\n          return;\n        } else {\n          state.restoreFromSnapshot(snapshot);\n        }\n      } else if (\n        state.contextualKeyword === ContextualKeyword._using &&\n        !hasFollowingLineBreak() &&\n        // Statements like `using[0]` and `using in foo` aren't actual using\n        // declarations.\n        lookaheadType() === tt.name\n      ) {\n        parseVarStatement(true);\n        return;\n      } else if (startsAwaitUsing()) {\n        expectContextual(ContextualKeyword._await);\n        parseVarStatement(true);\n        return;\n      }\n    default:\n      // Do nothing.\n      break;\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  const initialTokensLength = state.tokens.length;\n  parseExpression();\n  let simpleName = null;\n  if (state.tokens.length === initialTokensLength + 1) {\n    const token = state.tokens[state.tokens.length - 1];\n    if (token.type === tt.name) {\n      simpleName = token.contextualKeyword;\n    }\n  }\n  if (simpleName == null) {\n    semicolon();\n    return;\n  }\n  if (eat(tt.colon)) {\n    parseLabeledStatement();\n  } else {\n    // This was an identifier, so we might want to handle flow/typescript-specific cases.\n    parseIdentifierStatement(simpleName);\n  }\n}\n\n/**\n * Determine if we're positioned at an `await using` declaration.\n *\n * Note that this can happen either in place of a regular variable declaration\n * or in a loop body, and in both places, there are similar-looking cases where\n * we need to return false.\n *\n * Examples returning true:\n * await using foo = bar();\n * for (await using a of b) {}\n *\n * Examples returning false:\n * await using\n * await using + 1\n * await using instanceof T\n * for (await using;;) {}\n *\n * For now, we early return if we don't see `await`, then do a simple\n * backtracking-based lookahead for the `using` and identifier tokens. In the\n * future, this could be optimized with a character-based approach.\n */\nfunction startsAwaitUsing() {\n  if (!isContextual(ContextualKeyword._await)) {\n    return false;\n  }\n  const snapshot = state.snapshot();\n  // await\n  next();\n  if (!isContextual(ContextualKeyword._using) || hasPrecedingLineBreak()) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n  // using\n  next();\n  if (!match(tt.name) || hasPrecedingLineBreak()) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  }\n  state.restoreFromSnapshot(snapshot);\n  return true;\n}\n\nexport function parseDecorators() {\n  while (match(tt.at)) {\n    parseDecorator();\n  }\n}\n\nfunction parseDecorator() {\n  next();\n  if (eat(tt.parenL)) {\n    parseExpression();\n    expect(tt.parenR);\n  } else {\n    parseIdentifier();\n    while (eat(tt.dot)) {\n      parseIdentifier();\n    }\n    parseMaybeDecoratorArguments();\n  }\n}\n\nfunction parseMaybeDecoratorArguments() {\n  if (isTypeScriptEnabled) {\n    tsParseMaybeDecoratorArguments();\n  } else {\n    baseParseMaybeDecoratorArguments();\n  }\n}\n\nexport function baseParseMaybeDecoratorArguments() {\n  if (eat(tt.parenL)) {\n    parseCallExpressionArguments();\n  }\n}\n\nfunction parseBreakContinueStatement() {\n  next();\n  if (!isLineTerminator()) {\n    parseIdentifier();\n    semicolon();\n  }\n}\n\nfunction parseDebuggerStatement() {\n  next();\n  semicolon();\n}\n\nfunction parseDoStatement() {\n  next();\n  parseStatement(false);\n  expect(tt._while);\n  parseParenExpression();\n  eat(tt.semi);\n}\n\nfunction parseForStatement() {\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  parseAmbiguousForStatement();\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\n/**\n * Determine if this token is a `using` declaration (explicit resource\n * management) as part of a loop.\n * https://github.com/tc39/proposal-explicit-resource-management\n */\nfunction isUsingInLoop() {\n  if (!isContextual(ContextualKeyword._using)) {\n    return false;\n  }\n  // This must be `for (using of`, where `using` is the name of the loop\n  // variable.\n  if (isLookaheadContextual(ContextualKeyword._of)) {\n    return false;\n  }\n  return true;\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\nfunction parseAmbiguousForStatement() {\n  next();\n\n  let forAwait = false;\n  if (isContextual(ContextualKeyword._await)) {\n    forAwait = true;\n    next();\n  }\n  expect(tt.parenL);\n\n  if (match(tt.semi)) {\n    if (forAwait) {\n      unexpected();\n    }\n    parseFor();\n    return;\n  }\n\n  const isAwaitUsing = startsAwaitUsing();\n  if (isAwaitUsing || match(tt._var) || match(tt._let) || match(tt._const) || isUsingInLoop()) {\n    if (isAwaitUsing) {\n      expectContextual(ContextualKeyword._await);\n    }\n    next();\n    parseVar(true, state.type !== tt._var);\n    if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n      parseForIn(forAwait);\n      return;\n    }\n    parseFor();\n    return;\n  }\n\n  parseExpression(true);\n  if (match(tt._in) || isContextual(ContextualKeyword._of)) {\n    parseForIn(forAwait);\n    return;\n  }\n  if (forAwait) {\n    unexpected();\n  }\n  parseFor();\n}\n\nfunction parseFunctionStatement() {\n  const functionStart = state.start;\n  next();\n  parseFunction(functionStart, true);\n}\n\nfunction parseIfStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n  if (eat(tt._else)) {\n    parseStatement(false);\n  }\n}\n\nfunction parseReturnStatement() {\n  next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (!isLineTerminator()) {\n    parseExpression();\n    semicolon();\n  }\n}\n\nfunction parseSwitchStatement() {\n  next();\n  parseParenExpression();\n  state.scopeDepth++;\n  const startTokenIndex = state.tokens.length;\n  expect(tt.braceL);\n\n  // Don't bother validation; just go through any sequence of cases, defaults, and statements.\n  while (!match(tt.braceR) && !state.error) {\n    if (match(tt._case) || match(tt._default)) {\n      const isCase = match(tt._case);\n      next();\n      if (isCase) {\n        parseExpression();\n      }\n      expect(tt.colon);\n    } else {\n      parseStatement(true);\n    }\n  }\n  next(); // Closing brace\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, false));\n  state.scopeDepth--;\n}\n\nfunction parseThrowStatement() {\n  next();\n  parseExpression();\n  semicolon();\n}\n\nfunction parseCatchClauseParam() {\n  parseBindingAtom(true /* isBlockScope */);\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeAnnotation();\n  }\n}\n\nfunction parseTryStatement() {\n  next();\n\n  parseBlock();\n\n  if (match(tt._catch)) {\n    next();\n    let catchBindingStartTokenIndex = null;\n    if (match(tt.parenL)) {\n      state.scopeDepth++;\n      catchBindingStartTokenIndex = state.tokens.length;\n      expect(tt.parenL);\n      parseCatchClauseParam();\n      expect(tt.parenR);\n    }\n    parseBlock();\n    if (catchBindingStartTokenIndex != null) {\n      // We need a special scope for the catch binding which includes the binding itself and the\n      // catch block.\n      const endTokenIndex = state.tokens.length;\n      state.scopes.push(new Scope(catchBindingStartTokenIndex, endTokenIndex, false));\n      state.scopeDepth--;\n    }\n  }\n  if (eat(tt._finally)) {\n    parseBlock();\n  }\n}\n\nexport function parseVarStatement(isBlockScope) {\n  next();\n  parseVar(false, isBlockScope);\n  semicolon();\n}\n\nfunction parseWhileStatement() {\n  next();\n  parseParenExpression();\n  parseStatement(false);\n}\n\nfunction parseEmptyStatement() {\n  next();\n}\n\nfunction parseLabeledStatement() {\n  parseStatement(true);\n}\n\n/**\n * Parse a statement starting with an identifier of the given name. Subclasses match on the name\n * to handle statements like \"declare\".\n */\nfunction parseIdentifierStatement(contextualKeyword) {\n  if (isTypeScriptEnabled) {\n    tsParseIdentifierStatement(contextualKeyword);\n  } else if (isFlowEnabled) {\n    flowParseIdentifierStatement(contextualKeyword);\n  } else {\n    semicolon();\n  }\n}\n\n// Parse a semicolon-enclosed block of statements.\nexport function parseBlock(isFunctionScope = false, contextId = 0) {\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  expect(tt.braceL);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  parseBlockBody(tt.braceR);\n  if (contextId) {\n    state.tokens[state.tokens.length - 1].contextId = contextId;\n  }\n  const endTokenIndex = state.tokens.length;\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, isFunctionScope));\n  state.scopeDepth--;\n}\n\nexport function parseBlockBody(end) {\n  while (!eat(end) && !state.error) {\n    parseStatement(true);\n  }\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\nfunction parseFor() {\n  expect(tt.semi);\n  if (!match(tt.semi)) {\n    parseExpression();\n  }\n  expect(tt.semi);\n  if (!match(tt.parenR)) {\n    parseExpression();\n  }\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\nfunction parseForIn(forAwait) {\n  if (forAwait) {\n    eatContextual(ContextualKeyword._of);\n  } else {\n    next();\n  }\n  parseExpression();\n  expect(tt.parenR);\n  parseStatement(false);\n}\n\n// Parse a list of variable declarations.\n\nfunction parseVar(isFor, isBlockScope) {\n  while (true) {\n    parseVarHead(isBlockScope);\n    if (eat(tt.eq)) {\n      const eqIndex = state.tokens.length - 1;\n      parseMaybeAssign(isFor);\n      state.tokens[eqIndex].rhsEndIndex = state.tokens.length;\n    }\n    if (!eat(tt.comma)) {\n      break;\n    }\n  }\n}\n\nfunction parseVarHead(isBlockScope) {\n  parseBindingAtom(isBlockScope);\n  if (isTypeScriptEnabled) {\n    tsAfterParseVarHead();\n  } else if (isFlowEnabled) {\n    flowAfterParseVarHead();\n  }\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseFunction(\n  functionStart,\n  isStatement,\n  optionalId = false,\n) {\n  if (match(tt.star)) {\n    next();\n  }\n\n  if (isStatement && !optionalId && !match(tt.name) && !match(tt._yield)) {\n    unexpected();\n  }\n\n  let nameScopeStartTokenIndex = null;\n\n  if (match(tt.name)) {\n    // Expression-style functions should limit their name's scope to the function body, so we make\n    // a new function scope to enforce that.\n    if (!isStatement) {\n      nameScopeStartTokenIndex = state.tokens.length;\n      state.scopeDepth++;\n    }\n    parseBindingIdentifier(false);\n  }\n\n  const startTokenIndex = state.tokens.length;\n  state.scopeDepth++;\n  parseFunctionParams();\n  parseFunctionBodyAndFinish(functionStart);\n  const endTokenIndex = state.tokens.length;\n  // In addition to the block scope of the function body, we need a separate function-style scope\n  // that includes the params.\n  state.scopes.push(new Scope(startTokenIndex, endTokenIndex, true));\n  state.scopeDepth--;\n  if (nameScopeStartTokenIndex !== null) {\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, true));\n    state.scopeDepth--;\n  }\n}\n\nexport function parseFunctionParams(\n  allowModifiers = false,\n  funcContextId = 0,\n) {\n  if (isTypeScriptEnabled) {\n    tsStartParseFunctionParams();\n  } else if (isFlowEnabled) {\n    flowStartParseFunctionParams();\n  }\n\n  expect(tt.parenL);\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n  parseBindingList(\n    tt.parenR,\n    false /* isBlockScope */,\n    false /* allowEmpty */,\n    allowModifiers,\n    funcContextId,\n  );\n  if (funcContextId) {\n    state.tokens[state.tokens.length - 1].contextId = funcContextId;\n  }\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\nexport function parseClass(isStatement, optionalId = false) {\n  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later\n  // code can easily navigate to meaningful points on the class.\n  const contextId = getNextContextId();\n\n  next();\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  state.tokens[state.tokens.length - 1].isExpression = !isStatement;\n  // Like with functions, we declare a special \"name scope\" from the start of the name to the end\n  // of the class, but only with expression-style classes, to represent the fact that the name is\n  // available to the body of the class but not an outer declaration.\n  let nameScopeStartTokenIndex = null;\n  if (!isStatement) {\n    nameScopeStartTokenIndex = state.tokens.length;\n    state.scopeDepth++;\n  }\n  parseClassId(isStatement, optionalId);\n  parseClassSuper();\n  const openBraceIndex = state.tokens.length;\n  parseClassBody(contextId);\n  if (state.error) {\n    return;\n  }\n  state.tokens[openBraceIndex].contextId = contextId;\n  state.tokens[state.tokens.length - 1].contextId = contextId;\n  if (nameScopeStartTokenIndex !== null) {\n    const endTokenIndex = state.tokens.length;\n    state.scopes.push(new Scope(nameScopeStartTokenIndex, endTokenIndex, false));\n    state.scopeDepth--;\n  }\n}\n\nfunction isClassProperty() {\n  return match(tt.eq) || match(tt.semi) || match(tt.braceR) || match(tt.bang) || match(tt.colon);\n}\n\nfunction isClassMethod() {\n  return match(tt.parenL) || match(tt.lessThan);\n}\n\nfunction parseClassBody(classContextId) {\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (eat(tt.semi)) {\n      continue;\n    }\n\n    if (match(tt.at)) {\n      parseDecorator();\n      continue;\n    }\n    const memberStart = state.start;\n    parseClassMember(memberStart, classContextId);\n  }\n}\n\nfunction parseClassMember(memberStart, classContextId) {\n  if (isTypeScriptEnabled) {\n    tsParseModifiers([\n      ContextualKeyword._declare,\n      ContextualKeyword._public,\n      ContextualKeyword._protected,\n      ContextualKeyword._private,\n      ContextualKeyword._override,\n    ]);\n  }\n  let isStatic = false;\n  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._static) {\n    parseIdentifier(); // eats 'static'\n    if (isClassMethod()) {\n      parseClassMethod(memberStart, /* isConstructor */ false);\n      return;\n    } else if (isClassProperty()) {\n      parseClassProperty();\n      return;\n    }\n    // otherwise something static\n    state.tokens[state.tokens.length - 1].type = tt._static;\n    isStatic = true;\n\n    if (match(tt.braceL)) {\n      // This is a static block. Mark the word \"static\" with the class context ID for class element\n      // detection and parse as a regular block.\n      state.tokens[state.tokens.length - 1].contextId = classContextId;\n      parseBlock();\n      return;\n    }\n  }\n\n  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);\n}\n\nfunction parseClassMemberWithIsStatic(\n  memberStart,\n  isStatic,\n  classContextId,\n) {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseClassMemberWithIsStatic(isStatic)) {\n      return;\n    }\n  }\n  if (eat(tt.star)) {\n    // a generator\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n    return;\n  }\n\n  // Get the identifier name so we can tell if it's actually a keyword like \"async\", \"get\", or\n  // \"set\".\n  parseClassPropertyName(classContextId);\n  let isConstructor = false;\n  const token = state.tokens[state.tokens.length - 1];\n  // We allow \"constructor\" as either an identifier or a string.\n  if (token.contextualKeyword === ContextualKeyword._constructor) {\n    isConstructor = true;\n  }\n  parsePostMemberNameModifiers();\n\n  if (isClassMethod()) {\n    parseClassMethod(memberStart, isConstructor);\n  } else if (isClassProperty()) {\n    parseClassProperty();\n  } else if (token.contextualKeyword === ContextualKeyword._async && !isLineTerminator()) {\n    state.tokens[state.tokens.length - 1].type = tt._async;\n    // an async method\n    const isGenerator = match(tt.star);\n    if (isGenerator) {\n      next();\n    }\n\n    // The so-called parsed name would have been \"async\": get the real name.\n    parseClassPropertyName(classContextId);\n    parsePostMemberNameModifiers();\n    parseClassMethod(memberStart, false /* isConstructor */);\n  } else if (\n    (token.contextualKeyword === ContextualKeyword._get ||\n      token.contextualKeyword === ContextualKeyword._set) &&\n    !(isLineTerminator() && match(tt.star))\n  ) {\n    if (token.contextualKeyword === ContextualKeyword._get) {\n      state.tokens[state.tokens.length - 1].type = tt._get;\n    } else {\n      state.tokens[state.tokens.length - 1].type = tt._set;\n    }\n    // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n    // a getter or setter\n    // The so-called parsed name would have been \"get/set\": get the real name.\n    parseClassPropertyName(classContextId);\n    parseClassMethod(memberStart, /* isConstructor */ false);\n  } else if (token.contextualKeyword === ContextualKeyword._accessor && !isLineTerminator()) {\n    parseClassPropertyName(classContextId);\n    parseClassProperty();\n  } else if (isLineTerminator()) {\n    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n    parseClassProperty();\n  } else {\n    unexpected();\n  }\n}\n\nfunction parseClassMethod(functionStart, isConstructor) {\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n  parseMethod(functionStart, isConstructor);\n}\n\n// Return the name of the class property, if it is a simple identifier.\nexport function parseClassPropertyName(classContextId) {\n  parsePropertyName(classContextId);\n}\n\nexport function parsePostMemberNameModifiers() {\n  if (isTypeScriptEnabled) {\n    const oldIsType = pushTypeContext(0);\n    eat(tt.question);\n    popTypeContext(oldIsType);\n  }\n}\n\nexport function parseClassProperty() {\n  if (isTypeScriptEnabled) {\n    eatTypeToken(tt.bang);\n    tsTryParseTypeAnnotation();\n  } else if (isFlowEnabled) {\n    if (match(tt.colon)) {\n      flowParseTypeAnnotation();\n    }\n  }\n\n  if (match(tt.eq)) {\n    const equalsTokenIndex = state.tokens.length;\n    next();\n    parseMaybeAssign();\n    state.tokens[equalsTokenIndex].rhsEndIndex = state.tokens.length;\n  }\n  semicolon();\n}\n\nfunction parseClassId(isStatement, optionalId = false) {\n  if (\n    isTypeScriptEnabled &&\n    (!isStatement || optionalId) &&\n    isContextual(ContextualKeyword._implements)\n  ) {\n    return;\n  }\n\n  if (match(tt.name)) {\n    parseBindingIdentifier(true);\n  }\n\n  if (isTypeScriptEnabled) {\n    tsTryParseTypeParameters();\n  } else if (isFlowEnabled) {\n    if (match(tt.lessThan)) {\n      flowParseTypeParameterDeclaration();\n    }\n  }\n}\n\n// Returns true if there was a superclass.\nfunction parseClassSuper() {\n  let hasSuper = false;\n  if (eat(tt._extends)) {\n    parseExprSubscripts();\n    hasSuper = true;\n  } else {\n    hasSuper = false;\n  }\n  if (isTypeScriptEnabled) {\n    tsAfterParseClassSuper(hasSuper);\n  } else if (isFlowEnabled) {\n    flowAfterParseClassSuper(hasSuper);\n  }\n}\n\n// Parses module export declaration.\n\nexport function parseExport() {\n  const exportIndex = state.tokens.length - 1;\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExport()) {\n      return;\n    }\n  }\n  // export * from '...'\n  if (shouldParseExportStar()) {\n    parseExportStar();\n  } else if (isExportDefaultSpecifier()) {\n    // export default from\n    parseIdentifier();\n    if (match(tt.comma) && lookaheadType() === tt.star) {\n      expect(tt.comma);\n      expect(tt.star);\n      expectContextual(ContextualKeyword._as);\n      parseIdentifier();\n    } else {\n      parseExportSpecifiersMaybe();\n    }\n    parseExportFrom();\n  } else if (eat(tt._default)) {\n    // export default ...\n    parseExportDefaultExpression();\n  } else if (shouldParseExportDeclaration()) {\n    parseExportDeclaration();\n  } else {\n    // export { x, y as z } [from '...']\n    parseExportSpecifiers();\n    parseExportFrom();\n  }\n  state.tokens[exportIndex].rhsEndIndex = state.tokens.length;\n}\n\nfunction parseExportDefaultExpression() {\n  if (isTypeScriptEnabled) {\n    if (tsTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  if (isFlowEnabled) {\n    if (flowTryParseExportDefaultExpression()) {\n      return;\n    }\n  }\n  const functionStart = state.start;\n  if (eat(tt._function)) {\n    parseFunction(functionStart, true, true);\n  } else if (isContextual(ContextualKeyword._async) && lookaheadType() === tt._function) {\n    // async function declaration\n    eatContextual(ContextualKeyword._async);\n    eat(tt._function);\n    parseFunction(functionStart, true, true);\n  } else if (match(tt._class)) {\n    parseClass(true, true);\n  } else if (match(tt.at)) {\n    parseDecorators();\n    parseClass(true, true);\n  } else {\n    parseMaybeAssign();\n    semicolon();\n  }\n}\n\nfunction parseExportDeclaration() {\n  if (isTypeScriptEnabled) {\n    tsParseExportDeclaration();\n  } else if (isFlowEnabled) {\n    flowParseExportDeclaration();\n  } else {\n    parseStatement(true);\n  }\n}\n\nfunction isExportDefaultSpecifier() {\n  if (isTypeScriptEnabled && tsIsDeclarationStart()) {\n    return false;\n  } else if (isFlowEnabled && flowShouldDisallowExportDefaultSpecifier()) {\n    return false;\n  }\n  if (match(tt.name)) {\n    return state.contextualKeyword !== ContextualKeyword._async;\n  }\n\n  if (!match(tt._default)) {\n    return false;\n  }\n\n  const _next = nextTokenStart();\n  const lookahead = lookaheadTypeAndKeyword();\n  const hasFrom =\n    lookahead.type === tt.name && lookahead.contextualKeyword === ContextualKeyword._from;\n  if (lookahead.type === tt.comma) {\n    return true;\n  }\n  // lookahead again when `export default from` is seen\n  if (hasFrom) {\n    const nextAfterFrom = input.charCodeAt(nextTokenStartSince(_next + 4));\n    return nextAfterFrom === charCodes.quotationMark || nextAfterFrom === charCodes.apostrophe;\n  }\n  return false;\n}\n\nfunction parseExportSpecifiersMaybe() {\n  if (eat(tt.comma)) {\n    parseExportSpecifiers();\n  }\n}\n\nexport function parseExportFrom() {\n  if (eatContextual(ContextualKeyword._from)) {\n    parseExprAtom();\n    maybeParseImportAttributes();\n  }\n  semicolon();\n}\n\nfunction shouldParseExportStar() {\n  if (isFlowEnabled) {\n    return flowShouldParseExportStar();\n  } else {\n    return match(tt.star);\n  }\n}\n\nfunction parseExportStar() {\n  if (isFlowEnabled) {\n    flowParseExportStar();\n  } else {\n    baseParseExportStar();\n  }\n}\n\nexport function baseParseExportStar() {\n  expect(tt.star);\n\n  if (isContextual(ContextualKeyword._as)) {\n    parseExportNamespace();\n  } else {\n    parseExportFrom();\n  }\n}\n\nfunction parseExportNamespace() {\n  next();\n  state.tokens[state.tokens.length - 1].type = tt._as;\n  parseIdentifier();\n  parseExportSpecifiersMaybe();\n  parseExportFrom();\n}\n\nfunction shouldParseExportDeclaration() {\n  return (\n    (isTypeScriptEnabled && tsIsDeclarationStart()) ||\n    (isFlowEnabled && flowShouldParseExportDeclaration()) ||\n    state.type === tt._var ||\n    state.type === tt._const ||\n    state.type === tt._let ||\n    state.type === tt._function ||\n    state.type === tt._class ||\n    isContextual(ContextualKeyword._async) ||\n    match(tt.at)\n  );\n}\n\n// Parses a comma-separated list of module exports.\nexport function parseExportSpecifiers() {\n  let first = true;\n\n  // export { x, y as z } [from '...']\n  expect(tt.braceL);\n\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n    parseExportSpecifier();\n  }\n}\n\nfunction parseExportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseExportSpecifier();\n    return;\n  }\n  parseIdentifier();\n  state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ExportAccess;\n  if (eatContextual(ContextualKeyword._as)) {\n    parseIdentifier();\n  }\n}\n\n/**\n * Starting at the `module` token in an import, determine if it was truly an\n * import reflection token or just looks like one.\n *\n * Returns true for:\n * import module foo from \"foo\";\n * import module from from \"foo\";\n *\n * Returns false for:\n * import module from \"foo\";\n * import module, {bar} from \"foo\";\n */\nfunction isImportReflection() {\n  const snapshot = state.snapshot();\n  expectContextual(ContextualKeyword._module);\n  if (eatContextual(ContextualKeyword._from)) {\n    if (isContextual(ContextualKeyword._from)) {\n      state.restoreFromSnapshot(snapshot);\n      return true;\n    } else {\n      state.restoreFromSnapshot(snapshot);\n      return false;\n    }\n  } else if (match(tt.comma)) {\n    state.restoreFromSnapshot(snapshot);\n    return false;\n  } else {\n    state.restoreFromSnapshot(snapshot);\n    return true;\n  }\n}\n\n/**\n * Eat the \"module\" token from the import reflection proposal.\n * https://github.com/tc39/proposal-import-reflection\n */\nfunction parseMaybeImportReflection() {\n  // isImportReflection does snapshot/restore, so only run it if we see the word\n  // \"module\".\n  if (isContextual(ContextualKeyword._module) && isImportReflection()) {\n    next();\n  }\n}\n\n// Parses import declaration.\n\nexport function parseImport() {\n  if (isTypeScriptEnabled && match(tt.name) && lookaheadType() === tt.eq) {\n    tsParseImportEqualsDeclaration();\n    return;\n  }\n  if (isTypeScriptEnabled && isContextual(ContextualKeyword._type)) {\n    const lookahead = lookaheadTypeAndKeyword();\n    if (lookahead.type === tt.name && lookahead.contextualKeyword !== ContextualKeyword._from) {\n      // One of these `import type` cases:\n      // import type T = require('T');\n      // import type A from 'A';\n      expectContextual(ContextualKeyword._type);\n      if (lookaheadType() === tt.eq) {\n        tsParseImportEqualsDeclaration();\n        return;\n      }\n      // If this is an `import type...from` statement, then we already ate the\n      // type token, so proceed to the regular import parser.\n    } else if (lookahead.type === tt.star || lookahead.type === tt.braceL) {\n      // One of these `import type` cases, in which case we can eat the type token\n      // and proceed as normal:\n      // import type * as A from 'A';\n      // import type {a} from 'A';\n      expectContextual(ContextualKeyword._type);\n    }\n    // Otherwise, we are importing the name \"type\".\n  }\n\n  // import '...'\n  if (match(tt.string)) {\n    parseExprAtom();\n  } else {\n    parseMaybeImportReflection();\n    parseImportSpecifiers();\n    expectContextual(ContextualKeyword._from);\n    parseExprAtom();\n  }\n  maybeParseImportAttributes();\n  semicolon();\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction shouldParseDefaultImport() {\n  return match(tt.name);\n}\n\nfunction parseImportSpecifierLocal() {\n  parseImportedIdentifier();\n}\n\n// Parses a comma-separated list of module imports.\nfunction parseImportSpecifiers() {\n  if (isFlowEnabled) {\n    flowStartParseImportSpecifiers();\n  }\n\n  let first = true;\n  if (shouldParseDefaultImport()) {\n    // import defaultObj, { x, y as z } from '...'\n    parseImportSpecifierLocal();\n\n    if (!eat(tt.comma)) return;\n  }\n\n  if (match(tt.star)) {\n    next();\n    expectContextual(ContextualKeyword._as);\n\n    parseImportSpecifierLocal();\n\n    return;\n  }\n\n  expect(tt.braceL);\n  while (!eat(tt.braceR) && !state.error) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (eat(tt.colon)) {\n        unexpected(\n          \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n        );\n      }\n\n      expect(tt.comma);\n      if (eat(tt.braceR)) {\n        break;\n      }\n    }\n\n    parseImportSpecifier();\n  }\n}\n\nfunction parseImportSpecifier() {\n  if (isTypeScriptEnabled) {\n    tsParseImportSpecifier();\n    return;\n  }\n  if (isFlowEnabled) {\n    flowParseImportSpecifier();\n    return;\n  }\n  parseImportedIdentifier();\n  if (isContextual(ContextualKeyword._as)) {\n    state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.ImportAccess;\n    next();\n    parseImportedIdentifier();\n  }\n}\n\n/**\n * Parse import attributes like `with {type: \"json\"}`, or the legacy form\n * `assert {type: \"json\"}`.\n *\n * Import attributes technically have their own syntax, but are always parseable\n * as a plain JS object, so just do that for simplicity.\n */\nfunction maybeParseImportAttributes() {\n  if (match(tt._with) || (isContextual(ContextualKeyword._assert) && !hasPrecedingLineBreak())) {\n    next();\n    parseObj(false, false);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2340, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/thari/Desktop/face-recognition-project/face-recognition-app/node_modules/sucrase/dist/esm/parser/traverser/index.js"],"sourcesContent":["\nimport {nextToken, skipLineComment} from \"../tokenizer/index\";\nimport {charCodes} from \"../util/charcodes\";\nimport {input, state} from \"./base\";\nimport {parseTopLevel} from \"./statement\";\n\nexport function parseFile() {\n  // If enabled, skip leading hashbang line.\n  if (\n    state.pos === 0 &&\n    input.charCodeAt(0) === charCodes.numberSign &&\n    input.charCodeAt(1) === charCodes.exclamationMark\n  ) {\n    skipLineComment(2);\n  }\n  nextToken();\n  return parseTopLevel();\n}\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;AACA;;;;;AAEO,SAAS;IACd,0CAA0C;IAC1C,IACE,4PAAK,CAAC,GAAG,KAAK,KACd,4PAAK,CAAC,UAAU,CAAC,OAAO,gQAAS,CAAC,UAAU,IAC5C,4PAAK,CAAC,UAAU,CAAC,OAAO,gQAAS,CAAC,eAAe,EACjD;QACA,IAAA,uQAAe,EAAC;IAClB;IACA,IAAA,iQAAS;IACT,OAAO,IAAA,yQAAa;AACtB","ignoreList":[0],"debugId":null}}]
}